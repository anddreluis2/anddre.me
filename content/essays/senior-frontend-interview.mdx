---
title: "Senior frontend interview"
description: ""
publishedAt: "2026-02-10"
tags: ["react", "frontend", "architecture", "frontend-performance", "next"]
---

> This is a blogpost based on my repo: [senior-frontend-interview](https://github.com/anddreluis2/senior-frontend-interview/).

<br />

> Resuming in a few words: this is a list to you try to handle with your next frontend interviews, with a little FAQ based on my experience and of some friends.

<br />

> But first things first, I need to gave some credits to my friends [@mauvieira](https://github.com/mauvieira) and [@josethz00](https://github.com/josethz00) who helped me to build this repo.

<br />

Now let's divide this in topics:

<br />

- <u>[JavaScript questions](#javascript-interview-questions)</u>
- <u>[Architecture questions](#architecture-questions)</u>
- <u>[React questions](#react-questions)</u>
- <u>[React performance questions](#react-performance-questions)</u>
- <u>[Another common quesstions](#another-common-questions)</u>

<br />

<h1
  id="javascript-interview-questions"
  style={{
    fontSize: "2rem",
    fontWeight: 700,
    marginTop: 0,
    marginBottom: "1rem",
  }}
>
  JavaScript Interview Questions
</h1>

_Some questions about frontend development that might be in your next JavaScript job interview._

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Closure and Scope
</h2>

**Q: What is a closure and how does it work?**
A: A closure is a function that returns another function, by using a closure you can access the function of an inner scope calling one after the other

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Asynchronous Programming
</h2>

**Q: What are the differences between callbacks, promises, and async/await?**
A: A promise is a future, is a function that usually involves calling external resources and can take a while to finish
Callbacks are functions passed to promises, to be invoked when it finishes (see: Call me maybe)
Async/await is a modern syntax for promises in JavaScript, they have builtin error handling and are easier to understand, but they are not compatible with older versions

<br />

**Q: When would you use each?**
A: Async/await whenever is possible, to ensure code quality

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Event Loop and Concurrency Model
</h2>

**Q: How does the JavaScript event loop work?**
A: (No answer provided)

<br />

**Q: Explain the concept of the call stack and task queue.**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Prototype Inheritance vs. Classical Inheritance
</h2>

**Q: How does prototypal inheritance differ from classical inheritance?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Higher-Order Functions
</h2>

**Q: Can you explain what a higher-order function is in JavaScript and provide an example?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  DOM Manipulation and Event Handling
</h2>

**Q: How would you add an event listener in vanilla JavaScript?**
A: (No answer provided)

<br />

**Q: What are the differences between event capturing and bubbling?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  ES6 and Beyond Features
</h2>

**Q: Discuss arrow functions, template literals, destructuring, spread/rest operators, etc.**
A: (No answer provided)

<br />

## 'this' Keyword

**Q: How does the 'this' keyword work in JavaScript?**
A: (No answer provided)

<br />

**Q: What are the different ways to bind 'this' in a function?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Memory Management
</h2>

**Q: Discuss garbage collection and memory leaks in JavaScript.**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Design Patterns and Best Practices
</h2>

**Q: Discuss various design patterns (like Module, Observer, Singleton) and best practices in code organization and performance optimization.**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Testing and Debugging
</h2>

**Q: Discuss unit testing, integration testing, and debugging practices in JavaScript.**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Frameworks and Libraries
</h2>

**Q: Be prepared for questions related to specific frameworks (like React, Angular, or Node.js).**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Event Delegation
</h2>

**Q: Can you explain event delegation and why it's useful?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  JavaScript Engines
</h2>

**Q: How does a JavaScript engine like V8 execute code?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Hoisting
</h2>

**Q: What is hoisting in JavaScript and how does it affect variable and function declarations?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Immutability
</h2>

**Q: What is immutability and how can it be achieved in JavaScript?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Cross-Browser Compatibility Issues
</h2>

**Q: How do you ensure your JavaScript code works across different browsers?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Web Performance Optimization
</h2>

**Q: What are some ways to improve the performance of a JavaScript application?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Security Concerns
</h2>

**Q: What are common security threats in JavaScript and how do you prevent them?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Templating Engines and Server-Side Rendering
</h2>

**Q: If the role involves full-stack development, questions about server-side rendering and templating engines might come up.**
A: (No answer provided)

<br />

---

<br />

<h1
  id="architecture-questions"
  style={{
    fontSize: "2.25rem",
    fontWeight: 700,
    marginTop: 0,
    marginBottom: "1rem",
  }}
>
  Frontend architecture
</h1>

_This section contains common questions about frontend application architecture, with summarized answers._

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  üèõÔ∏è Fundamentals
</h2>
**Q: What are the main architectural patterns in modern frontend applications?**
A: MVC (Model-View-Controller), MVVM (Model-View-ViewModel), and Component-Driven
Architecture (CDA). CDA is the most common in modern frameworks like React.

<br />

**Q: What is separation of concerns?**
A: It is dividing the application into distinct modules with unique responsibilities. Example: separating UI, state logic, and API calls.

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  ‚öôÔ∏è Componentization
</h2>
**Q: What are reusable components?** A: UI blocks that can be used in different contexts,
following principles like DRY (Don't Repeat Yourself).

<br />

**Q: What should you consider when designing a scalable component architecture?**
A: Clear naming, composition, state isolation, and well-defined responsibilities.

<br />

**Q: When to use Context API, Redux, or other global state solutions?**
A: Context API for simple and local data. Redux or other libraries for complex state shared among many components.

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  üß© Micro Frontends
</h2>
**Q: What is a frontend monolith? And a micro frontend?** A: A monolith is a single
large application. Micro frontends split the UI into multiple independent apps that
coexist.

<br />

**Advantages of micro frontends:**

- Allow independent teams to develop, deploy, and scale parts of the application separately
- Enable incremental adoption of new technologies
- Reduce the impact of failures by isolating problems in smaller parts

<br />

**Challenges of micro frontends:**

- Complexity of integration between different micro frontends
- Possible increase in bundle size due to duplicated dependencies
- Managing communication and state sharing between micro frontends

<br />

**Best practices for micro frontends:**

- Define clear communication contracts (events, APIs)
- Use a shared design system to maintain visual consistency
- Automate deployments and continuous integration for each micro frontend
- Monitor performance and end-user experience across the entire application

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  üì¶ Folder Structure
</h2>
**Q: How do you structure folders in a large React application?** A: By domain (`features/user`,
`features/orders`) or by type (`components/`, `pages/`, `hooks/`), depending on the
team and project scale.

<br />

**Q: Domain-driven folders vs. file type?**
A: Domain-based structure makes scalability and maintainability easier in large systems. By type is simpler for small teams.

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  üß† Performance and Scalability
</h2>
**Q: How does architecture influence application performance?** A: Modularity and
lazy loading reduce load time and make the bundle smaller.

<br />

**Q: Strategies for lazy loading and bundle optimization?**
A: `React.lazy`, `Suspense`, dynamic imports, route splitting, and bundle analysis with tools like Webpack Bundle Analyzer.

<br />

**Q: When to use Server Components or SSR (Next.js)?**
A: SSR improves SEO and TTFB. Server Components help avoid unnecessary client-side renders.

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  üõ†Ô∏è Tools and Patterns
</h2>
**Q: How does using TypeScript impact architecture?** A: It helps prevent errors
during development and makes code more predictable and documented.

<br />

**Q: Best practices with Tailwind, Styled Components, or CSS Modules?**
A: Separate visual responsibilities, avoid logic in styles, and prefer consistent patterns throughout the project.

<br />

**Q: What is the importance of linting, testing, and CI/CD?**
A: Linting prevents style/code issues. Testing ensures stability. CI/CD automates delivery and reduces errors.

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  üîê Security
</h2>
**Q: Architectural security concerns in the frontend?** A: Input sanitization, correct
use of tokens and headers, avoid exposing sensitive data in the bundle.

<br />

**Q: How to protect sensitive information in the frontend?**
A: Do not put secrets in client code. Use environment variables on the backend and expose only what is necessary via a secure API.

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  üìö References
</h2>
- [The Clean Architecture by Uncle Bob](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Component-Driven Development](https://www.componentdriven.org/) - [Official Next.js
Guide on Project Architecture](https://nextjs.org/docs/advanced-features/project-structure)

<br />
<br />
---

<br />

<h1
  id="react-questions"
  style={{
    fontSize: "2.25rem",
    fontWeight: 700,
    marginTop: 0,
    marginBottom: "1rem",
  }}
>
  React Questions
</h1>

_Here we can see some theoretical things that you will probably face in an interview_

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Reconciliation Algorithm and how it impacts performance
</h2>

The React Reconciliation algorithm is the process by which React efficiently updates the DOM. When a component's state or props change, React creates a new virtual DOM tree and compares it with the previous one (diffing).

- React uses a heuristic O(n) algorithm instead of traditional O(n¬≥) tree diffing
- First compares elements of the same type
- Uses keys to identify which children were changed, added, or removed
- Updates only the parts of the DOM that changed

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Code-splitting in a React application
</h2>

Code-splitting is a technique to divide your bundle into smaller chunks that can be loaded on demand, improving initial load time. React supports code-splitting via:

1. **React.lazy():** Allows components to be loaded only when needed
2. **Suspense**: Provides a loading state while components are being loaded
3. **Route-based splitting**: Loading components based on routes

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Describe the render props pattern and how it compares to hooks
</h2>

The render props pattern is a technique for sharing code between components using a prop whose value is a function. It was popular before hooks were introduced.

**Render Props**:

- Passes functions as props to share logic
- Can lead to "callback hell" and deeply nested components
- More verbose than hooks
- Still useful for certain UI composition patterns

**Hooks**:

- More concise and readable
- Easier to compose multiple pieces of logic
- Cannot be used conditionally (must follow hook rules)
- Sometimes less flexible for complex UI composition

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  State Management
</h2>

- Client State
  - UI state (modals, tabs, etc)
  - User preferences
  - Application state, not from server
  - Complex client-side logic
- Server State
  - Data fetched from APIs
  - Data that needs caching
  - Background refetching
  - Optimistic Updates - Optimistic updates are a UI pattern where the application immediately updates the interface after a user action, without waiting for server confirmation.
- URL State
  - Pros: Shareable, Favorable, State Persistence
  - Uses: Filters, Selected Tabs, Selected Items, Multi-Step Flows
  - When not to use: Sensitive Information, High-frequency changes, Large Data Structures

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  useReducer and useState
</h2>

We can implement a custom hook similar to useState using useReducer, creating a simple reducer that replaces the state with what is dispatched to it. Returns a tuple with the state and dispatch function.

<br />

```tsx
const [state, dispatch] = useReducer(reducer, initialArg, init?)
```

<br />

**reducer**: Must be pure, must receive **state** and **action** as arguments, must return the **next state**

**initialArg**

**init**: Initializer function that should return the initial state

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  useEffect Drama
</h2>

**useEffect** and **useLayoutEffect** are both hooks for handling side effects, but differ in their execution timing:

<br />

**useEffect**

- executes asynchronously after the browser has painted
- doesn't block the browser from updating
- side effects

<br />
**useLayoutEffect**

- executes synchronously **after** React performs DOM mutations
- but **before** browser painting
- blocks the browser from painting until the effect is completed
- modifies the DOM and wants to avoid visual flickering

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  API Calls
</h2>

**useEffect Limitations**

- Race Conditions: handling non-sequential order
- No built-in features for: retry, deduplication (multiple components requesting the same data), manual loading and error states, complex to clean up and avoid memory leaks, waterfalls (Sequential data dependencies create request cascades), no background refetching

  <br />
  **Best Practices**

- Custom Hook with AbortController: Create a new AbortController for this request, pass the signal to the request, if the signal is not aborted set the data. Cleanup: abort the request if component is unmounted or URL changes
- Custom Hook with AbortController and Request Deduplication: Create a cache key based on URL and options, check if there's already a pending request for this URL, if not create a new promise and store it in the cache (local), remove from cache when completed

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Refs Refs Refs
</h2>

**forwardRef**: component receives a ref and forwards it to a child DOM element or component. Use cases: accessing a DOM element inside a child, imperatively triggering actions on a child component, triggering input focus via ref

<br />

**useImperativeHandle**: customizes the instance exposed when using a reference, allows a child to expose specific functions or properties to the parent. Use cases: wanting to limit which parts of a component are accessible via ref, exposing and customizing imperative methods. Example: modal triggering API on close

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Performance
</h2>

**How to measure?**

- DevTools: Record and interact, Analyze the flamegraph
- Render duration, Commit frequency, Wasted renders
- Custom hook with `performance.now()`
- `why-did-you-render` library to track unnecessary re-renders
- when **useMemo** is useful: calculation is computationally expensive, dependencies change infrequently, calculation result is used in the rendering phase

<br />
**Practical Approach**:

1. identify bottlenecks using tools
2. measure impact of optimizations
3. apply targeted optimizations
4. measure again

<br />

**useCallback**: memoized version of the callback function that only changes if one of its dependencies has changed. Has a small performance cost, just part of the optimization strategy, not everywhere. Use cases: passing functions to optimized child components

<br />

**Q: What is INP and how would you optimize it in a React application?**
A: INP (Interaction to Next Paint) is a Core Web Vital that measures responsiveness to user interactions such as clicks, taps, and keyboard inputs. It became an official Google ranking factor in March 2024, with a "good" threshold below 200ms. To optimize INP in a React application:

1. Profile performance using Chrome DevTools Performance panel
2. Implement code-splitting and lazy loading with React.lazy() and Suspense
3. Optimize event handlers with debouncing and event delegation
4. Leverage React 18 concurrent features with startTransition
5. Eliminate unnecessary re-renders with React.memo() and useMemo()
6. Split long tasks into smaller chunks

As seen in the Vio case study, these optimizations can improve INP from poor scores (380ms) to good ones (175ms).

<br />

**Q: How would you approach migrating a client-rendered React application to Next.js for better performance?**
A: Based on DoorDash's migration strategy:

1. Implement an incremental approach - migrate page by page
2. Create a bridge between environments with shared context and isSSR flag
3. Optimize SSR with lazy hydration for non-critical components
4. Implement file-based routing replacing React Router
5. Focus on high-impact pages first
6. Establish monitoring and fallbacks

<br />

**Q: What challenges might you face when migrating to Next.js App Router and how would you address them?**
A: Based on Inngest's experience:

1. **Understanding the new caching behavior**: Start by disabling cache for dynamic data (export const dynamic = "force-dynamic")
2. **Managing global state across layouts**: Move global state to URL parameters
3. **Adapting to new routing conventions**: Leverage file-based structure with layout.js, page.js, loading.js, error.js
4. **Balancing static and dynamic content**: Use static rendering where possible, stream dynamic content with React's streaming SSR

<br />

**Q: How would you decide between SSR, CSR, and hybrid approaches in a Next.js application?**
A: **Use SSR for**: Entry points and landing pages that need SEO, content-heavy pages, pages indexable by search engines, initial application shell. **Use CSR for**: Highly interactive parts after initial load, internal dashboards, features requiring frequent updates, components dependent on client-side APIs. **Hybrid (recommended)**: SSR for initial shell and critical content, CSR for subsequent interactions, progressive hydration, streaming SSR.

<br />

**Q: What caching strategies would you implement in a Next.js application to balance performance and data freshness?**
A:

1. **CDN/Edge**: Configure cache headers, use ISR with revalidation, stale-while-revalidate
2. **App Router caching**: cache: 'no-store' for dynamic data, time-based revalidation with next.revalidate, on-demand revalidation
3. **Client-side**: React Query or SWR with staleness times
4. **Monitoring**: Add monitoring, implement cache invalidation, test with fresh and cached data

<br />

**Q: How has state management in React applications evolved, and what approach would you recommend for a large-scale application?**
A: **Current best practices**:

1. Keep state local when possible
2. React Context for shared state
3. React Query/SWR for server state, Zustand or Jotai for global UI state, React Hook Form for forms
4. Server-side state with Server Components
5. Redux only for complex cases

**Recommendation**: Modular approach, separate server state (React Query) from client state (Context/Zustand), place state close to where needed, URL params for routing state, proper memoization.

<br />

**Q: How would you ensure accessibility in a React/Next.js application?**
A:

1. **Semantic HTML and ARIA**: Appropriate elements, ARIA when needed, follow ARIA Authoring Practices
2. **Keyboard navigation**: All interactive elements keyboard accessible, manage focus for modals, expected shortcuts
3. **Test with assistive technologies**: Screen readers, keyboard-only testing, axe-core or Lighthouse
4. **Framework features**: Next.js built-in features, accessible component libraries
5. **From the start**: Include in design, train developers, part of definition of done

<br />
<br />

---

<br />
<br />

<h1
  id="react-performance-questions"
  style={{
    fontSize: "2.25rem",
    fontWeight: 700,
    marginTop: 0,
    marginBottom: "1rem",
  }}
>
  React Performance & Best Practices
</h1>

_Some best practices to keep the performance on top_

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  1. Eliminating Async Waterfalls
</h2>

**Q: What are "async waterfalls" and why are they problematic?**
A: Async waterfalls occur when asynchronous operations are executed sequentially, one waiting for the other to complete, even when there's no real dependency between them. This is problematic because:

- Significantly increases total loading time
- Unnecessarily blocks the UI
- Wastes resources by not leveraging parallelism

<br />
**‚ùå Incorrect (Sequential/Waterfall):**
```tsx
async function load(id: string, skip: boolean) {
  const data = await fetchData(id); // Blocks even if skip is true
  if (skip) return null;
  return process(data);
}
```

<br />
**‚úÖ Correct (Non-blocking):**
```tsx
async function load(id: string, skip: boolean) {
  if (skip) return null;
  const data = await fetchData(id);
  return process(data);
}
```

<br />

**Q: How to use Promise.all to avoid waterfalls in multiple async calls?**
A: When there are multiple independent async calls, use `Promise.all()` or start the promises simultaneously before awaiting.

<br />
**‚ùå Incorrect (Sequential):**
```tsx
const userData = await fetchUser(id);
const posts = await fetchPosts(id); // Unnecessarily waits for user to finish
const comments = await fetchComments(id); // Waits for user AND posts to finish
```

<br />
**‚úÖ Correct (Parallel):**
```tsx
// Option 1: Promise.all when all are needed
const [userData, posts, comments] = await Promise.all([
  fetchUser(id),
  fetchPosts(id),
  fetchComments(id),
]);

// Option 2: Start all simultaneously and await as needed
const userDataPromise = fetchUser(id);
const postsPromise = fetchPosts(id);
const commentsPromise = fetchComments(id);

const userData = await userDataPromise;
const posts = await postsPromise;
const comments = await commentsPromise;
```

<br />

**Q: How to avoid waterfalls with TanStack Query?**
A: With TanStack Query, use `enabled` only for necessary validation, not to create cascades. Independent queries should start simultaneously.

<br />
**‚ùå Incorrect:**
```tsx
const { data: user } = useQuery({
  queryKey: ['user', id],
  queryFn: () => fetchUser(id),
});

const { data: posts } = useQuery({
  queryKey: ['posts', id],
  queryFn: () => fetchPosts(id),
  enabled: !!user, // Waterfall! Only fetches posts after user
});
````

<br />
**‚úÖ Correct (Parallel):**
```tsx
const { data: user } = useQuery({
  queryKey: ['user', id],
  queryFn: () => fetchUser(id),
});

const { data: posts } = useQuery({
queryKey: ['posts', id],
queryFn: () => fetchPosts(id),
enabled: !!id, // Doesn't depend on user
});

````
<br />
**‚úÖ Correct (Real Dependency):**
```tsx
const { data: user } = useQuery({
  queryKey: ['user', id],
  queryFn: () => fetchUser(id),
});

const { data: posts } = useQuery({
  queryKey: ['posts', user?.userId],
  queryFn: () => fetchPosts(user.userId),
  enabled: !!user?.userId, // OK: real data dependency
});
````

<br />

**Q: What is "data proximity" and how to apply this concept?**
A: Data proximity means fetching data as close as possible to where it will be consumed, avoiding "prop drilling" of pending states.

<br />
**‚ùå Incorrect (Loading Prop Drilling):**
```tsx
function Parent() {
  const { data: user } = useQuery(['user'], fetchUser);
  const { data: posts } = useQuery(['posts'], fetchPosts);
  const { data: comments } = useQuery(['comments'], fetchComments);
  return <Child user={user} posts={posts} comments={comments} />;
}

function Child({ user, posts, comments }) {
return <CommentsList comments={comments} />;
}

````

<br />
**‚úÖ Correct (Proximity):**
```tsx
function Parent() {
  const { data: user } = useQuery(['user'], fetchUser);
  return (
    <>
      <UserProfile user={user} />
      <PostsSection userId={user?.id} />
    </>
  );
}

function PostsSection({ userId }) {
  const { data: posts } = useQuery(
    ['posts', userId],
    () => fetchPosts(userId),
    { enabled: !!userId }
  );
  return <PostsList posts={posts} />;
}
````

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  2. Render Optimization and Re-renders
</h2>

**Q: When and how to use useMemo to optimize render calculations?**
A: Use `useMemo` to avoid unnecessary recalculations of complex logic or array transformations that don't need to be redone on every render.

<br />
**‚ùå Incorrect:**
```tsx
function ProductList({ products, filter, sortBy }) {
  const filtered = products.filter((p) => p.category === filter);
  const sorted = filtered.sort((a, b) => {
    if (sortBy === "price") return a.price - b.price;
    return a.name.localeCompare(b.name);
  });
  return (
    <div>
      {sorted.map((p) => (
        <Product key={p.id} {...p} />
      ))}
    </div>
  );
}
```

**‚úÖ Correct:**

```tsx
function ProductList({ products, filter, sortBy }) {
  const sorted = useMemo(() => {
    const filtered = products.filter((p) => p.category === filter);
    return filtered.sort((a, b) => {
      if (sortBy === "price") return a.price - b.price;
      return a.name.localeCompare(b.name);
    });
  }, [products, filter, sortBy]);
  return (
    <div>
      {sorted.map((p) => (
        <Product key={p.id} {...p} />
      ))}
    </div>
  );
}
```

<br />

**Q: When to use useCallback and what's its impact on function stability?**
A: Use `useCallback` for functions passed as props to child components that use `React.memo`, or when the function is a dependency of another hook.

<br />
**‚ùå Incorrect:**

```tsx
const MemoizedButton = React.memo(Button);

function Parent({ items }) {
  const handleClick = (id: string) => {
    console.log("Clicked", id);
  };
  return items.map((item) => (
    <MemoizedButton key={item.id} onClick={() => handleClick(item.id)} />
  ));
}
```

**‚úÖ Correct:**

```tsx
const MemoizedButton = React.memo(Button);

function Parent({ items }) {
  const handleClick = useCallback((id: string) => {
    console.log("Clicked", id);
  }, []);
  return items.map((item) => (
    <MemoizedButton key={item.id} id={item.id} onClick={handleClick} />
  ));
}
```

**‚ö†Ô∏è Important:** Don't use `useCallback` unnecessarily. Only use when: the function is passed to a memoized component (`React.memo`), or the function is a dependency of another hook (`useEffect`, `useMemo`).

<br />

**Q: Why shouldn't we put high-frequency states in React Context?**
A: High-frequency states (like text inputs) in global Contexts cause re-renders in all components consuming that context.

<br />
**‚ùå Incorrect:**

```tsx
const SearchContext = createContext();

function SearchProvider({ children }) {
  const [searchTerm, setSearchTerm] = useState("");
  return (
    <SearchContext.Provider value={{ searchTerm, setSearchTerm }}>
      {children}
    </SearchContext.Provider>
  );
}

function UnrelatedComponent() {
  const { searchTerm } = useContext(SearchContext);
  return <div>Static content</div>;
}
```

<br />
**‚úÖ Correct:**

```tsx
function SearchInput() {
  const [searchTerm, setSearchTerm] = useState("");
  return (
    <input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
  );
}

// OR: Zustand with granular selectors
const useSearchStore = create((set) => ({
  searchTerm: "",
  setSearchTerm: (term) => set({ searchTerm: term }),
}));

function SearchInput() {
  const searchTerm = useSearchStore((s) => s.searchTerm);
  const setSearchTerm = useSearchStore((s) => s.setSearchTerm);
  return (
    <input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
  );
}
```

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  3. JavaScript Performance and Structures
</h2>

**Q: How to avoid multiple iterations over the same list?**
A: Combine operations like `filter`, `map`, and `reduce` into a single pass.

<br />
**‚ùå Incorrect (Multiple Iterations):**

```tsx
function processProducts(products: Product[]) {
  const active = products.filter((p) => p.active);
  const withDiscount = active.filter((p) => p.discount > 0);
  const prices = withDiscount.map((p) => p.price * (1 - p.discount));
  const total = prices.reduce((sum, p) => sum + p, 0);
  return total;
}
```

<br />
**‚úÖ Correct (Single Iteration):**

```tsx
function processProducts(products: Product[]) {
  return products.reduce((total, product) => {
    if (!product.active || product.discount === 0) return total;
    const discountedPrice = product.price * (1 - product.discount);
    return total + discountedPrice;
  }, 0);
}
```

<br />

**Q: What is the "early return" pattern and how does it improve readability?**
A: Early return means returning early for error or loading states, avoiding excessive nesting.

<br />
**‚ùå Incorrect:**

```tsx
function ProductPage({ productId }) {
  const {
    data: product,
    isLoading,
    error,
  } = useQuery(["product", productId], fetchProduct);
  return (
    <div>
      {isLoading ? (
        <Loading />
      ) : error ? (
        <Error />
      ) : product ? (
        <div>
          <h1>{product.name}</h1>
        </div>
      ) : null}
    </div>
  );
}
```

<br />
**‚úÖ Correct:**

```tsx
function ProductPage({ productId }) {
  const {
    data: product,
    isLoading,
    error,
  } = useQuery(["product", productId], fetchProduct);
  if (isLoading) return <Loading />;
  if (error) return <Error />;
  if (!product) return null;
  return (
    <div>
      <h1>{product.name}</h1>
    </div>
  );
}
```

<br />

**Q: Why is it important to cleanup in useEffect and how to implement it?**
A: Cleanup prevents memory leaks and inconsistent behavior when the component unmounts.

<br />
**‚ùå Incorrect:**

```tsx
useEffect(() => {
  const interval = setInterval(() => fetchData(), 1000);
  // No cleanup!
}, []);
```

<br />
**‚úÖ Correct:**

```tsx
useEffect(() => {
  const interval = setInterval(() => fetchData(), 1000);
  return () => clearInterval(interval);
}, []);
```

<br />
**‚úÖ Correct (AbortController for fetch):**

```tsx
useEffect(() => {
  const abortController = new AbortController();
  fetchData({ signal: abortController.signal })
    .then(setData)
    .catch((err) => {
      if (err.name !== "AbortError") setError(err);
    });
  return () => abortController.abort();
}, []);
```

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  4. Golden Rules - Summary
</h2>

**Q: What are the main golden rules for React performance?**
A:

- **Parallel Queries**: With TanStack Query, start independent queries simultaneously. Use `enabled` only for necessary validation.
- **useMemo for Transformations**: Use for calculations with array iterations, values used in multiple places, or expensive computations.
- **useCallback for Stability**: Use when function is passed to `React.memo` or is a hook dependency.
- **Local vs Global State**: Local: inputs, forms. Zustand: global state with selectors. TanStack Query: server state.
- **Avoid Waterfalls**: Don't await conditionally used data. Use `Promise.all`. Start independent queries together.
- **Early Returns**: Return loading/error before main JSX. Avoid nested ternaries.

<br />
<br />

---

<br />
<br />

<h1
  id="another-common-questions"
  style={{
    fontSize: "2.25rem",
    fontWeight: 700,
    marginTop: 0,
    marginBottom: "1rem",
  }}
>
  Another common questions
</h1>

**Q: What are the strategies we can use to optimize the performance of web applications?**
A: CDNs, GraphQL (maybe) to reduce overfetching, improve backend performance, use SSR and/or SSG, lazy loading for loading assets only when it's needed, minimize and compress HTML, CSS and JS files, and optimize images by compressing and resizing them.

<br />

**Q: What are Web Vitals (LCP, FID, CLS)? And how are they applied in the real world?**
A: Web Vitals are standardized metrics to measure the quality of the navigation inside a website:

- LCP (Largest Contentful Paint) - LCP measures the time it takes for the largest visible content element to be fully loaded and rendered. A LCP is considered good when it takes less than 2.5 seconds.
- FID (First Input Delay) - FID measures the time it takes for the browser to respond to the user's first interaction. A FID is considered good when it takes less than 100 milliseconds.
- CLS (Cumulative Layout Shift) - CLS measures the visual stability of a page by calculating the sum of layout shift scores for all unexpected layout shifts during the entire lifespan of the page.

<br />

**Q: What is the WAI-ARIA standard?**
A: Web Accessibility Initiative - Accessible Rich Internet Applications, is a technical specification developed by the World Wide Web Consortium (W3C). The purpose of WAI-ARIA is to improve the accessibility of web content and applications, especially for users with disabilities who rely on assistive technologies, such as screen readers or alternative input devices.

<br />

**Q: In which cases is it worth building an SPA?**
A:

- Mobile app-like experience and PWA
- Complex state management, because they are able to maintain persistent state and handle real-time updates
- Highly interactive user interfaces, because there's no reload, so transitions between views are faster

<br />

<h2
  id="default-frontend-javascript"
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  JavaScript
</h2>

**Q: What is the advantage of using a Map instead of an object?**
A:

- With maps you can use keys of any type, not only strings as in javascript objects
- Provides an iterator for easy for-of usage
- Support millions of items

<br />

**Q: What is the difference between Map and WeakMap?**
A: WeakMaps keys must be objects. Besides that, WeakMaps have weak references to the keys, so unused keys can be easily removed by the garbage collector

<br />

**Q: What are closures? (a very common question)**
A: One function that has a function inside, and return it. This technique is used to capture the scope on which they were defined, so you can use variables of that scope outside it.

<br />

**Q: What is hoisting?**
A: Elevate functions and variables declarations to the "top scope". This allows you to use a function or a variable before it is defined in your .js file.

<br />

**Q: How does equality work in JS? What is the difference between using === and Object.is()?**
A: Object.is considers NaN equals to NaN and -0 different than +0.

<br />

**Q: What is the purpose of Object.freeze()?**
A: Makes an object immutable, preventing it to have its value changed.

<br />

**Q: What is the difference between an async-await function and using a chain of .then?**
A: Callback hell

<br />

**Q: How do generators work?**
A: Generators are on-demand functions, they can be paused and resumed, and the state is maintained along these "pauses and resumes". They return a generator object, each key of this object is the result of and yield operation, the last key is the return result.

<br />

<h2
  id="default-frontend-css"
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  CSS
</h2>

**Q: How does CSS-in-JS work?**
A: It is an approach that allows writing CSS directly within JavaScript files, making code maintenance and modularization easier.

<br />

**Q: Why does Facebook no longer want to follow the same direction as CSS-in-JS?**
A: Doesn't generate a static CSS file, it generates a JS file and set all the styles through it, and then the styles interact with the browser through the CSSStyleSheet API. Generating a static CSS file would be more performatic.

<br />

**Q: What is the proposal of the Stylex library?**
A: It's a library to manage CSS styles in an efficient and modular way.

<br />

**Q: How to use nesting with pure CSS only?**
A: It's being discussed lately, it's very recent and will be implemented in the next versions. But, so far it's only possible by using CSS preprocessors.

<br />

**Q: What are container queries?**
A: A way to apply styles based on the container size, instead of the window view size It makes the styles more responsive.

<br />

**Q: How does the CSS grid subgrid work?**
A: The CSS Grid subgrid feature is an extension of the CSS Grid Layout Module that allows a nested grid to inherit its parent grid's rows or columns. This is especially useful when you want to align the content of nested grid items with the parent grid's structure, without having to duplicate row and column definitions or manage complex positioning with margins or padding.

<br />

<h2
  id="default-frontend-react"
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  React
</h2>

**Q: What is the Virtual DOM? And why is it often more performant than manipulating the "real" DOM?**
A:

- Virtual DOM is a JavaScript object containing a replica to the real DOM, it is capable of making comparisons with the real DOM, and then apply patches avoiding a full re-render in the DOM, rerendering only what have changed.
- Virtual DOM is a programming concept where a virtual representation of a UI is kept in memory synced with "Real DOM" by a library such as ReactDOM and this process is called reconciliation
- Virtual DOM makes the performance faster, not because the processing itself is done in less time. The reason is the amount of changed information ‚Äì rather than wasting time on updating the entire page, you can dissect it into small elements and interactions

<br />

**Q: Explain why the useState hook accepts a function as an initial value**
A: To allow the initial value to be calculated only once, instead of every time

<br />

**Q: What is the difference between the hooks useState and useReducer?**
A: useState is better for simple state management, without too much logic involved, and useReducer was designed to handle complex state logics, and states that requires transition and dispatch actions.

<br />

**Q: Under what circumstances does a component re-render in React?**
A:

- Changes in props: When a component receives new props, it triggers a re-render. This happens even if the new props are the same as the old ones.
- Changes in state: When a component's state is updated, a re-render is triggered.
- Parent component re-renders: When a parent component re-renders, by default, its child components also re-render.
- Context changes: If a component is consuming values from a React context using useContext (in functional components), and the context value changes, the component will re-render.
- Using hooks with dependencies: Hooks like useEffect, useMemo, and useCallback accept dependency arrays as their second argument. When any of the listed dependencies change, the effect will run, or the memoized value or callback will be recomputed, potentially causing the component to re-render.

<br />

**Q: How can we prevent unnecessary rerenders?**
A:

- React.memo
- Use the hook dependencies correctly in useCallback, useEffect and useMemo to avoid re-renders
- For big forms, prefer useRef over useState

<br />

**Q: What is the advantage of using the React.memo API?**
A: Prevents unnecessary renders when the component's props haven't changed, improving performance

<br />

**Q: What are the purposes of the hooks useRef, useMemo, and useCallback?**
A:

- useRef: Allows you to create a mutable reference object that persists across renders. It is commonly used to store references to DOM elements, but can also be used to store values that should persist without triggering a rerender (input values for example).
- useMemo: Memoizes a computed value, preventing unnecessary recomputations when dependencies haven't changed. This can improve performance when working with expensive computations that depend on specific prop or state values.
- useCallback: Memoizes a callback function, ensuring that the same instance of the function is reused across renders unless its dependencies change. This is useful for preventing unnecessary rerenders in child components that receive the callback as a prop.

<br />

**Q: What is virtualization? And what is it for?**
A: Virtualization is a technique used to optimize the rendering of large lists or grids by only rendering the visible items on the screen. It improves performance by reducing the number of DOM elements created and updated, minimizing memory usage, and reducing layout calculations.

<br />

**Q: Explain how the useEffect hook works**
A: The useEffect hook is used to perform side effects in functional components, such as fetching data, updating the DOM, or subscribing to events. It takes two arguments: a function that contains the side effect, and an optional dependency array. The effect function runs after the component renders and updates. If the dependency array is provided, the effect will only run when one of the listed dependencies changes. If the array is empty, the effect will run only on mount and unmount.

<br />

**Q: How can we do event cleanup in useEffect?**
A: By returning a "cleanup function" in the end of the useEffect A cleanup function is a function with a removeEventListener call inside it. As you are returning this cleanup function, the cleanup will happen every time the effect happens (it will vary on the dependencies array of your useEffect)

<br />

**Q: What is the recommended way to consume external data in React?**
A: useEffect hook to fetch data when the component mounts or when relevant dependencies change. The fetched data can then be stored in the component's state using the useState or useReducer hooks.
You can use axios or fetch for consuming REST APIs, and apollo-client, relay or urql if you are consuming a GraphQL API. You can also consume other types of APIs, for example gRPC and SOAP, although these API patterns are not that common in frontend applications.
tRPC (t3-app) and server-components (next.js) are a very recent way to consume external data.

<br />

**Q: What is the difference between server state and application state?**
A:

- Server state refers to the data stored on the server or external services, typically fetched via APIs.
- Application state refers to the data that is specific to a user's interaction with the application, such as user preferences, UI state, context or data that is temporarily cached on the client-side.

<br />

**Q: How can a React application be deployed without any meta-framework?**
A:

- Write a build script in the package.json, and also a start build script
- Choose a provider that supports a SPA.
- Deploy the application through CLI, FTP or git remote repository.
- Generate the build
- Configure the provider to start the application pointing to the build directory (usually dist)

<br />

**Q: What is a meta-framework in the context of web development?**
A:

- Framework built on top of other frameworks or libraries
- Next.js --> React.js
- Nuxtjs --> Vue.js
- NestJS --> Express and Fastify
- Type-GraphQL --> GraphQL

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Next
</h2>

**Q: What is the difference between getServerSideProps and getStaticProps?**
A:

- getStaticProps - used to get de component props and then render it into a static HTML page at build time
- getServerSideProps - used to get the component props and then render it into a static HTML page at run time

<br />

**Q: What is the purpose of the getStaticPaths function?**
A: Is used when your dynamic page has the getStaticProps. Nextjs needs to know what are the possible paths for your dynamic route, so you map them on the getStaticProps function. You can use getStaticProps without getStaticPaths; getStaticPaths is only a complement in case of dynamic routes

<br />

**Q: How does the next/image API work? And why does it improve the app's performance?**
A:

- The image is optimized by the Next.js server, or an external image optimization service. The optimization includes resizing, format conversion (to WEBP), and compression.
- The optimized image is served to the client with cache headers to enable caching by the browser or a CDN, which can improve performance on subsequent requests.

<br />

**Q: Explain how you would deploy a Next application without hosting it on Vercel**
A: You can deploy a Next.js application on any platform that supports Node.js, the only difference is that on Vercel this process is automated, is hidden by a great DX.

<br />

**Q: How do API routes work?**
A: Next.js API routes provide a built-in solution for creating API endpoints within a Next.js application. They are server-side functions that run when a request is made to their corresponding URL. To create an API route, simply create a new file with a .js extension inside the pages/api folder, and export a default request handler function.

<br />

**Q: Is it possible to API Routes if the app is not hosted on Vercel?**
A: Yes, you can use Next.js API routes even if your app is not hosted on Vercel. API routes work on any platform that supports Node.js, including custom deployments or other hosting providers.

<br />

**Q: How can we integrate AMP with Next?**
A: You'll need to import the withAmp higher-order component from next/amp and wrap your page component with it.

<br />

**Q: What is the advantage of using Serverless mode?**
A:

- Improved scalability, as serverless functions can automatically scale based on demand.
- Cost efficiency, as you only pay for the compute resources you actually use.
- Easier deployment and management, as you don't need to manage your own servers or infrastructure.
- Faster response times due to the serverless functions being deployed closer to the users.

<br />

**Q: Is it possible to use a static CDN with Next?**
A: Yes, you can use a static CDN with Next.js by configuring the assetPrefix option in your next.config.js file. The assetPrefix should be set to the URL of your CDN.

<br />
