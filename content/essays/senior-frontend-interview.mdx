---
title: "Senior frontend interview"
description: ""
publishedAt: "2026-02-10"
tags: ["react", "frontend", "architecture", "frontend-performance", "next"]
---

> This is a blogpost based on my repo: [senior-frontend-interview](https://github.com/anddreluis2/senior-frontend-interview/).

<br />

> Resuming in a few words: this is a list to you try to handle with your next frontend interviews, with a little FAQ based on my experience and of some friends.

<br />

> But first things first, I need to gave some credits to my friends [@mauvieira](https://github.com/mauvieira) and [@josethz00](https://github.com/josethz00) who helped me to build this repo.

<br />

Now let's divide this in topics:

<br />

- <u>[JavaScript questions](#javascript-interview-questions)</u>
- <u>[Architecture questions](#architecture-questions)</u>
- <u>[React questions](#react-questions)</u>
- <u>[React performance questions](#react-performance-questions)</u>
- <u>[Another common quesstions](#another-common-questions)</u>

<br />

<h1
  id="javascript-interview-questions"
  style={{
    fontSize: "2rem",
    fontWeight: 700,
    marginTop: 0,
    marginBottom: "1rem",
  }}
>
  JavaScript Interview Questions
</h1>

Some questions about frontend development that might be in your next JavaScript job interview.

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Closure and Scope
</h2>

**Q: What is a closure and how does it work?**
A: A closure is a function that returns another function, by using a closure you can access the function of an inner scope calling one after the other

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Asynchronous Programming
</h2>

**Q: What are the differences between callbacks, promises, and async/await?**
A: A promise is a future, is a function that usually involves calling external resources and can take a while to finish
Callbacks are functions passed to promises, to be invoked when it finishes (see: Call me maybe)
Async/await is a modern syntax for promises in JavaScript, they have builtin error handling and are easier to understand, but they are not compatible with older versions

<br />

**Q: When would you use each?**
A: Async/await whenever is possible, to ensure code quality

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Event Loop and Concurrency Model
</h2>

**Q: How does the JavaScript event loop work?**
A: (No answer provided)

<br />

**Q: Explain the concept of the call stack and task queue.**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Prototype Inheritance vs. Classical Inheritance
</h2>

**Q: How does prototypal inheritance differ from classical inheritance?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Higher-Order Functions
</h2>

**Q: Can you explain what a higher-order function is in JavaScript and provide an example?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  DOM Manipulation and Event Handling
</h2>

**Q: How would you add an event listener in vanilla JavaScript?**
A: (No answer provided)

<br />

**Q: What are the differences between event capturing and bubbling?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  ES6 and Beyond Features
</h2>

**Q: Discuss arrow functions, template literals, destructuring, spread/rest operators, etc.**
A: (No answer provided)

<br />

## 'this' Keyword

**Q: How does the 'this' keyword work in JavaScript?**
A: (No answer provided)

<br />

**Q: What are the different ways to bind 'this' in a function?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Memory Management
</h2>

**Q: Discuss garbage collection and memory leaks in JavaScript.**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Design Patterns and Best Practices
</h2>

**Q: Discuss various design patterns (like Module, Observer, Singleton) and best practices in code organization and performance optimization.**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Testing and Debugging
</h2>

**Q: Discuss unit testing, integration testing, and debugging practices in JavaScript.**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Frameworks and Libraries
</h2>

**Q: Be prepared for questions related to specific frameworks (like React, Angular, or Node.js).**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Event Delegation
</h2>

**Q: Can you explain event delegation and why it's useful?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  JavaScript Engines
</h2>

**Q: How does a JavaScript engine like V8 execute code?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Hoisting
</h2>

**Q: What is hoisting in JavaScript and how does it affect variable and function declarations?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Immutability
</h2>

**Q: What is immutability and how can it be achieved in JavaScript?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Cross-Browser Compatibility Issues
</h2>

**Q: How do you ensure your JavaScript code works across different browsers?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Web Performance Optimization
</h2>

**Q: What are some ways to improve the performance of a JavaScript application?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Security Concerns
</h2>

**Q: What are common security threats in JavaScript and how do you prevent them?**
A: (No answer provided)

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Templating Engines and Server-Side Rendering
</h2>

**Q: If the role involves full-stack development, questions about server-side rendering and templating engines might come up.**
A: (No answer provided)

<br />

## Architecture questions

_Content coming soon._

<br />

## React questions

_Content coming soon._

<br />

## React performance questions

_Content coming soon._

<br />
<br />

---

<br />
<br />

<h1
  id="another-common-questions"
  style={{
    fontSize: "2.25rem",
    fontWeight: 700,
    marginTop: 0,
    marginBottom: "1rem",
  }}
>
  Another common questions
</h1>

**Q: What are the strategies we can use to optimize the performance of web applications?**
A: CDNs, GraphQL (maybe) to reduce overfetching, improve backend performance, use SSR and/or SSG, lazy loading for loading assets only when it's needed, minimize and compress HTML, CSS and JS files, and optimize images by compressing and resizing them.

<br />

**Q: What are Web Vitals (LCP, FID, CLS)? And how are they applied in the real world?**
A: Web Vitals are standardized metrics to measure the quality of the navigation inside a website:

- LCP (Largest Contentful Paint) - LCP measures the time it takes for the largest visible content element to be fully loaded and rendered. A LCP is considered good when it takes less than 2.5 seconds.
- FID (First Input Delay) - FID measures the time it takes for the browser to respond to the user's first interaction. A FID is considered good when it takes less than 100 milliseconds.
- CLS (Cumulative Layout Shift) - CLS measures the visual stability of a page by calculating the sum of layout shift scores for all unexpected layout shifts during the entire lifespan of the page.

<br />

**Q: What is the WAI-ARIA standard?**
A: Web Accessibility Initiative - Accessible Rich Internet Applications, is a technical specification developed by the World Wide Web Consortium (W3C). The purpose of WAI-ARIA is to improve the accessibility of web content and applications, especially for users with disabilities who rely on assistive technologies, such as screen readers or alternative input devices.

<br />

**Q: In which cases is it worth building an SPA?**
A:

- Mobile app-like experience and PWA
- Complex state management, because they are able to maintain persistent state and handle real-time updates
- Highly interactive user interfaces, because there's no reload, so transitions between views are faster

<br />

<h2
  id="default-frontend-javascript"
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  JavaScript
</h2>

**Q: What is the advantage of using a Map instead of an object?**
A:

- With maps you can use keys of any type, not only strings as in javascript objects
- Provides an iterator for easy for-of usage
- Support millions of items

<br />

**Q: What is the difference between Map and WeakMap?**
A: WeakMaps keys must be objects. Besides that, WeakMaps have weak references to the keys, so unused keys can be easily removed by the garbage collector

<br />

**Q: What are closures? (a very common question)**
A: One function that has a function inside, and return it. This technique is used to capture the scope on which they were defined, so you can use variables of that scope outside it.

<br />

**Q: What is hoisting?**
A: Elevate functions and variables declarations to the "top scope". This allows you to use a function or a variable before it is defined in your .js file.

<br />

**Q: How does equality work in JS? What is the difference between using === and Object.is()?**
A: Object.is considers NaN equals to NaN and -0 different than +0.

<br />

**Q: What is the purpose of Object.freeze()?**
A: Makes an object immutable, preventing it to have its value changed.

<br />

**Q: What is the difference between an async-await function and using a chain of .then?**
A: Callback hell

<br />

**Q: How do generators work?**
A: Generators are on-demand functions, they can be paused and resumed, and the state is maintained along these "pauses and resumes". They return a generator object, each key of this object is the result of and yield operation, the last key is the return result.

<br />

<h2
  id="default-frontend-css"
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  CSS
</h2>

**Q: How does CSS-in-JS work?**
A: It is an approach that allows writing CSS directly within JavaScript files, making code maintenance and modularization easier.

<br />

**Q: Why does Facebook no longer want to follow the same direction as CSS-in-JS?**
A: Doesn't generate a static CSS file, it generates a JS file and set all the styles through it, and then the styles interact with the browser through the CSSStyleSheet API. Generating a static CSS file would be more performatic.

<br />

**Q: What is the proposal of the Stylex library?**
A: It's a library to manage CSS styles in an efficient and modular way.

<br />

**Q: How to use nesting with pure CSS only?**
A: It's being discussed lately, it's very recent and will be implemented in the next versions. But, so far it's only possible by using CSS preprocessors.

<br />

**Q: What are container queries?**
A: A way to apply styles based on the container size, instead of the window view size It makes the styles more responsive.

<br />

**Q: How does the CSS grid subgrid work?**
A: The CSS Grid subgrid feature is an extension of the CSS Grid Layout Module that allows a nested grid to inherit its parent grid's rows or columns. This is especially useful when you want to align the content of nested grid items with the parent grid's structure, without having to duplicate row and column definitions or manage complex positioning with margins or padding.

<br />

<h2
  id="default-frontend-react"
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  React
</h2>

**Q: What is the Virtual DOM? And why is it often more performant than manipulating the "real" DOM?**
A:

- Virtual DOM is a JavaScript object containing a replica to the real DOM, it is capable of making comparisons with the real DOM, and then apply patches avoiding a full re-render in the DOM, rerendering only what have changed.
- Virtual DOM is a programming concept where a virtual representation of a UI is kept in memory synced with "Real DOM" by a library such as ReactDOM and this process is called reconciliation
- Virtual DOM makes the performance faster, not because the processing itself is done in less time. The reason is the amount of changed information â€“ rather than wasting time on updating the entire page, you can dissect it into small elements and interactions

<br />

**Q: Explain why the useState hook accepts a function as an initial value**
A: To allow the initial value to be calculated only once, instead of every time

<br />

**Q: What is the difference between the hooks useState and useReducer?**
A: useState is better for simple state management, without too much logic involved, and useReducer was designed to handle complex state logics, and states that requires transition and dispatch actions.

<br />

**Q: Under what circumstances does a component re-render in React?**
A:

- Changes in props: When a component receives new props, it triggers a re-render. This happens even if the new props are the same as the old ones.
- Changes in state: When a component's state is updated, a re-render is triggered.
- Parent component re-renders: When a parent component re-renders, by default, its child components also re-render.
- Context changes: If a component is consuming values from a React context using useContext (in functional components), and the context value changes, the component will re-render.
- Using hooks with dependencies: Hooks like useEffect, useMemo, and useCallback accept dependency arrays as their second argument. When any of the listed dependencies change, the effect will run, or the memoized value or callback will be recomputed, potentially causing the component to re-render.

<br />

**Q: How can we prevent unnecessary rerenders?**
A:

- React.memo
- Use the hook dependencies correctly in useCallback, useEffect and useMemo to avoid re-renders
- For big forms, prefer useRef over useState

<br />

**Q: What is the advantage of using the React.memo API?**
A: Prevents unnecessary renders when the component's props haven't changed, improving performance

<br />

**Q: What are the purposes of the hooks useRef, useMemo, and useCallback?**
A:

- useRef: Allows you to create a mutable reference object that persists across renders. It is commonly used to store references to DOM elements, but can also be used to store values that should persist without triggering a rerender (input values for example).
- useMemo: Memoizes a computed value, preventing unnecessary recomputations when dependencies haven't changed. This can improve performance when working with expensive computations that depend on specific prop or state values.
- useCallback: Memoizes a callback function, ensuring that the same instance of the function is reused across renders unless its dependencies change. This is useful for preventing unnecessary rerenders in child components that receive the callback as a prop.

<br />

**Q: What is virtualization? And what is it for?**
A: Virtualization is a technique used to optimize the rendering of large lists or grids by only rendering the visible items on the screen. It improves performance by reducing the number of DOM elements created and updated, minimizing memory usage, and reducing layout calculations.

<br />

**Q: Explain how the useEffect hook works**
A: The useEffect hook is used to perform side effects in functional components, such as fetching data, updating the DOM, or subscribing to events. It takes two arguments: a function that contains the side effect, and an optional dependency array. The effect function runs after the component renders and updates. If the dependency array is provided, the effect will only run when one of the listed dependencies changes. If the array is empty, the effect will run only on mount and unmount.

<br />

**Q: How can we do event cleanup in useEffect?**
A: By returning a "cleanup function" in the end of the useEffect A cleanup function is a function with a removeEventListener call inside it. As you are returning this cleanup function, the cleanup will happen every time the effect happens (it will vary on the dependencies array of your useEffect)

<br />

**Q: What is the recommended way to consume external data in React?**
A: useEffect hook to fetch data when the component mounts or when relevant dependencies change. The fetched data can then be stored in the component's state using the useState or useReducer hooks.
You can use axios or fetch for consuming REST APIs, and apollo-client, relay or urql if you are consuming a GraphQL API. You can also consume other types of APIs, for example gRPC and SOAP, although these API patterns are not that common in frontend applications.
tRPC (t3-app) and server-components (next.js) are a very recent way to consume external data.

<br />

**Q: What is the difference between server state and application state?**
A:

- Server state refers to the data stored on the server or external services, typically fetched via APIs.
- Application state refers to the data that is specific to a user's interaction with the application, such as user preferences, UI state, context or data that is temporarily cached on the client-side.

<br />

**Q: How can a React application be deployed without any meta-framework?**
A:

- Write a build script in the package.json, and also a start build script
- Choose a provider that supports a SPA.
- Deploy the application through CLI, FTP or git remote repository.
- Generate the build
- Configure the provider to start the application pointing to the build directory (usually dist)

<br />

**Q: What is a meta-framework in the context of web development?**
A:

- Framework built on top of other frameworks or libraries
- Next.js --> React.js
- Nuxtjs --> Vue.js
- NestJS --> Express and Fastify
- Type-GraphQL --> GraphQL

<br />

<h2
  style={{
    fontSize: "1.5rem",
    fontWeight: 600,
    marginTop: "2rem",
    marginBottom: "0.5rem",
  }}
>
  Next
</h2>

**Q: What is the difference between getServerSideProps and getStaticProps?**
A:

- getStaticProps - used to get de component props and then render it into a static HTML page at build time
- getServerSideProps - used to get the component props and then render it into a static HTML page at run time

<br />

**Q: What is the purpose of the getStaticPaths function?**
A: Is used when your dynamic page has the getStaticProps. Nextjs needs to know what are the possible paths for your dynamic route, so you map them on the getStaticProps function. You can use getStaticProps without getStaticPaths; getStaticPaths is only a complement in case of dynamic routes

<br />

**Q: How does the next/image API work? And why does it improve the app's performance?**
A:

- The image is optimized by the Next.js server, or an external image optimization service. The optimization includes resizing, format conversion (to WEBP), and compression.
- The optimized image is served to the client with cache headers to enable caching by the browser or a CDN, which can improve performance on subsequent requests.

<br />

**Q: Explain how you would deploy a Next application without hosting it on Vercel**
A: You can deploy a Next.js application on any platform that supports Node.js, the only difference is that on Vercel this process is automated, is hidden by a great DX.

<br />

**Q: How do API routes work?**
A: Next.js API routes provide a built-in solution for creating API endpoints within a Next.js application. They are server-side functions that run when a request is made to their corresponding URL. To create an API route, simply create a new file with a .js extension inside the pages/api folder, and export a default request handler function.

<br />

**Q: Is it possible to API Routes if the app is not hosted on Vercel?**
A: Yes, you can use Next.js API routes even if your app is not hosted on Vercel. API routes work on any platform that supports Node.js, including custom deployments or other hosting providers.

<br />

**Q: How can we integrate AMP with Next?**
A: You'll need to import the withAmp higher-order component from next/amp and wrap your page component with it.

<br />

**Q: What is the advantage of using Serverless mode?**
A:

- Improved scalability, as serverless functions can automatically scale based on demand.
- Cost efficiency, as you only pay for the compute resources you actually use.
- Easier deployment and management, as you don't need to manage your own servers or infrastructure.
- Faster response times due to the serverless functions being deployed closer to the users.

<br />

**Q: Is it possible to use a static CDN with Next?**
A: Yes, you can use a static CDN with Next.js by configuring the assetPrefix option in your next.config.js file. The assetPrefix should be set to the URL of your CDN.

<br />
