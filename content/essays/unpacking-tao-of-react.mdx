---
title: "Unpacking Tao of React #1"
description: "An informal walkthrough of key architecture patterns inspired by Tao of React that saved my life in production."
publishedAt: "2024-04-01"
tags: ["react", "frontend", "architecture", "beginners"]
---

> Imagine you're a front-end dev and you don't know anything about software architecture. Now, imagine you have an interview tomorrow at exactly **7:32 AM** and you need to absorb some core conceptsâ€”_fast_.

While browsing the internet, you stumble across a specific bookâ€”but unfortunately, you don't have enough time to read it (after all, the interview is literally **tomorrow** at 7:32 AM ğŸ˜µâ€ğŸ’«).

If that sounds like you, this article (and the next ones) are for you.

The book I'm talking about is [**Tao Of React**](https://alexkondov.com/tao-of-react/) by Alex Kondov.

I decided to re-read it and share a few thoughts on how using some of its concepts worked for me **in production**. I'll go through specific topicsâ€”from folder structure to external libraries and state management decisions.

Let's dive in!

<br />

## 1. Architecture

_initially just folder organization lol_

<br />

## 1.1 The common module

The idea is simple: if you'll reuse it in more than one place, toss it in a `common` folder.

Not just componentsâ€”hooks, helpers, utils, anything reusable. Abstract it and centralize.

<br />

**Why?** To avoid duplication and make maintenance easier.

<br />

## 1.2 Absolute paths

This might sound like nitpicking, but once your project scales, you'll be _grateful_ for following this.

<br />

**Avoid this:**

```ts
import { foo } from "../../../../common/helpers/foo";
```

<br />

**Use this instead:**

```ts
import { foo } from "@common/helpers/foo";
```

<br />

**Why?** Clarity and flexibility. If you ever refactor folder structures, your imports stay clean and understandable.

<br />

## 1.3 Wrap components inside folders

Think about how you organize your clothesâ€”you don't mix shirts and pants randomly.

Now think about your components the same way.

What's easier to understand and maintain?

<br />

**âŒ Bad:**

```
components/
  â”œâ”€â”€ Button.tsx
  â”œâ”€â”€ Button.test.tsx
  â”œâ”€â”€ Button.styles.ts
  â”œâ”€â”€ Card.tsx
  â”œâ”€â”€ Card.test.tsx
  â”œâ”€â”€ Card.styles.ts
```

<br />

**âœ… Good:**

```
components/
  â”œâ”€â”€ Button/
  â”‚   â”œâ”€â”€ index.tsx
  â”‚   â”œâ”€â”€ Button.test.tsx
  â”‚   â””â”€â”€ Button.styles.ts
  â””â”€â”€ Card/
      â”œâ”€â”€ index.tsx
      â”œâ”€â”€ Card.test.tsx
      â””â”€â”€ Card.styles.ts
```

<br />

## 1.4 Route/Module structure

Simple rule: **Separation of Concerns**.

Each page (or module) should only contain stuff related to itself. If you're in the `home` page folder, there shouldn't be any code about the `dashboard` there.

Easy.

<br />

## 1.5 Modular dependencies

Here's where I respectfully disagree with Alex Kondov.

He mentions the **Rule of Three**: it's okay to repeat something up to three timesâ€”on the third time, refactor and abstract.

But I say:

<br />

> If you're using something from module X in module Yâ€”**it's already reusable**. Move it to `common`. Why wait?

<br />

## 1.6 External components

Imagine using a UI library's `Button` like this:

```tsx
<Button>Click Me</Button>
```

<br />

Suddenly, the library maintainers change it to:

```tsx
<Button placeholder="Click Me" />
```

<br />

Now you have to refactor _every instance_.

<br />

**Solution?** Create a wrapper around external components. So if the API changes, you only need to update it in _one_ place.

Yes, the example is exaggeratedâ€”but the lesson stands.

<br />

## What's next?

In the next article: **How to create a module efficiently?**

Basically, a step-by-step to not mess things up when modularizing your app.

<br />

## Closing

That's it for now! Hope you enjoyed the readâ€”I'm writing this the way I wish someone had explained it to me. Feedback is welcome âœŒï¸
