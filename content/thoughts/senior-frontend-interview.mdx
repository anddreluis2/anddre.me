---
title: "Senior frontend interview"
description: ""
publishedAt: "2026-02-10"
tags: ["react", "frontend", "architecture", "frontend-performance", "next"]
---

> This is a simple guide based on my repo: <u>[senior-frontend-interview](https://github.com/anddreluis2/senior-frontend-interview/)</u>.

<br />

> But first, I need to give some credit to my friends <u>[@mauvieira](https://github.com/mauvieira)</u> and <u>[@josethz00](https://github.com/josethz00)</u> who helped me build this repo.

<br />

I’ve divided this in very specific topics to make your life easier, so you can dive directly into your pain points.

<FolderAccordion title="JavaScript Interview Questions" level={1}>

_Some questions about frontend development that might be in your next JavaScript job interview._

<FolderAccordion title="Closure and Scope" level={2}>

<QAItem question="What is a closure and how does it work?">
A: A closure is a function that returns another function, by using a closure you can access the function of an inner scope calling one after the other

```javascript
function outer() {
  const message = "Hello";
  
  function inner() {
    console.log(message); // Can access outer's variable
  }
  
  return inner;
}

const myFunction = outer();
myFunction(); // Logs: "Hello"
```
</QAItem>

</FolderAccordion>

<FolderAccordion title="Asynchronous Programming" level={2}>

<QAItem question="What are the differences between callbacks, promises, and async/await?">
A: A promise is a future, is a function that usually involves calling external resources and can take a while to finish
Callbacks are functions passed to promises, to be invoked when it finishes (see: Call me maybe)
Async/await is a modern syntax for promises in JavaScript, they have builtin error handling and are easier to understand, but they are not compatible with older versions

```javascript
// Callback
fetchData(id, (error, data) => {
  if (error) console.error(error);
  else console.log(data);
});

// Promise
fetchData(id)
  .then(data => console.log(data))
  .catch(error => console.error(error));

// Async/Await
async function getData() {
  try {
    const data = await fetchData(id);
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}
```
</QAItem>

<br />

<QAItem question="When would you use each?">
A: Async/await whenever is possible, to ensure code quality
</QAItem>

</FolderAccordion>

<FolderAccordion title="Event Loop and Concurrency Model" level={2}>

<QAItem question="How does the JavaScript event loop work?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

<br />

<QAItem question="Explain the concept of the call stack and task queue.">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Prototype Inheritance vs. Classical Inheritance" level={2}>

<QAItem question="How does prototypal inheritance differ from classical inheritance?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Higher-Order Functions" level={2}>

<QAItem question="Can you explain what a higher-order function is in JavaScript and provide an example?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="DOM Manipulation and Event Handling" level={2}>

<QAItem question="How would you add an event listener in vanilla JavaScript?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

<br />

<QAItem question="What are the differences between event capturing and bubbling?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="ES6 and Beyond Features" level={2}>

<QAItem question="Discuss arrow functions, template literals, destructuring, spread/rest operators, etc.">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="'this' Keyword" level={2}>

<QAItem question="How does the 'this' keyword work in JavaScript?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

<br />

<QAItem question="What are the different ways to bind 'this' in a function?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Memory Management" level={2}>

<QAItem question="Discuss garbage collection and memory leaks in JavaScript.">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Design Patterns and Best Practices" level={2}>

<QAItem question="Discuss various design patterns (like Module, Observer, Singleton) and best practices in code organization and performance optimization.">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Testing and Debugging" level={2}>

<QAItem question="Discuss unit testing, integration testing, and debugging practices in JavaScript.">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Frameworks and Libraries" level={2}>

<QAItem question="Be prepared for questions related to specific frameworks (like React, Angular, or Node.js).">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Event Delegation" level={2}>

<QAItem question="Can you explain event delegation and why it's useful?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="JavaScript Engines" level={2}>

<QAItem question="How does a JavaScript engine like V8 execute code?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Hoisting" level={2}>

<QAItem question="What is hoisting in JavaScript and how does it affect variable and function declarations?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Immutability" level={2}>

<QAItem question="What is immutability and how can it be achieved in JavaScript?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Cross-Browser Compatibility Issues" level={2}>

<QAItem question="How do you ensure your JavaScript code works across different browsers?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Web Performance Optimization" level={2}>

<QAItem question="What are some ways to improve the performance of a JavaScript application?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Security Concerns" level={2}>

<QAItem question="What are common security threats in JavaScript and how do you prevent them?">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

<FolderAccordion title="Templating Engines and Server-Side Rendering" level={2}>

<QAItem question="If the role involves full-stack development, questions about server-side rendering and templating engines might come up.">
A: (No answer provided - you'll need to research this topic on your own)
</QAItem>

</FolderAccordion>

</FolderAccordion>

<FolderAccordion title="Frontend Architecture" level={1}>

_This section contains common questions about frontend application architecture, with summarized answers._

<FolderAccordion title="Fundamentals" level={2}>

<QAItem question="What are the main architectural patterns in modern frontend applications?">
A: MVC (Model-View-Controller), MVVM (Model-View-ViewModel), and Component-Driven
Architecture (CDA). CDA is the most common in modern frameworks like React.
</QAItem>

<br />

<QAItem question="What is separation of concerns?">
A: It is dividing the application into distinct modules with unique responsibilities. Example: separating UI, state logic, and API calls.
</QAItem>

</FolderAccordion>

<FolderAccordion title="Componentization" level={2}>

<QAItem question="What are reusable components?">
A: UI blocks that can be used in different contexts, following principles like DRY (Don't Repeat Yourself).
</QAItem>

<br />

<QAItem question="What should you consider when designing a scalable component architecture?">
A: Clear naming, composition, state isolation, and well-defined responsibilities.
</QAItem>

<br />

<QAItem question="When to use Context API, Redux, or other global state solutions?">
A: Context API for simple and local data. Redux or other libraries for complex state shared among many components.
</QAItem>

</FolderAccordion>

<FolderAccordion title="Micro Frontends" level={2}>

<QAItem question="What is a frontend monolith? And a micro frontend?">
A: A monolith is a single large application. Micro frontends split the UI into multiple independent apps that coexist.
</QAItem>

<br />

<QAItem question="What are the advantages of micro frontends?">
A:

- Allow independent teams to develop, deploy, and scale parts of the application separately
- Enable incremental adoption of new technologies
- Reduce the impact of failures by isolating problems in smaller parts
</QAItem>

<br />

<QAItem question="What are the challenges of micro frontends?">
A:

- Complexity of integration between different micro frontends
- Possible increase in bundle size due to duplicated dependencies
- Managing communication and state sharing between micro frontends
</QAItem>

<br />

<QAItem question="What are the best practices for micro frontends?">
A:

- Define clear communication contracts (events, APIs)
- Use a shared design system to maintain visual consistency
- Automate deployments and continuous integration for each micro frontend
- Monitor performance and end-user experience across the entire application
</QAItem>

</FolderAccordion>

<FolderAccordion title="Folder Structure" level={2}>

<QAItem question="How do you structure folders in a large React application?">
A: By domain (`features/user`, `features/orders`) or by type (`components/`, `pages/`, `hooks/`), depending on the team and project scale.
</QAItem>

<br />

<QAItem question="Domain-driven folders vs. file type?">
A: Domain-based structure makes scalability and maintainability easier in large systems. By type is simpler for small teams.
</QAItem>

</FolderAccordion>

<FolderAccordion title="Performance and Scalability" level={2}>

<QAItem question="How does architecture influence application performance?">
A: Modularity and lazy loading reduce load time and make the bundle smaller.
</QAItem>

<br />

<QAItem question="Strategies for lazy loading and bundle optimization?">
A: `React.lazy`, `Suspense`, dynamic imports, route splitting, and bundle analysis with tools like Webpack Bundle Analyzer.
</QAItem>

<br />

<QAItem question="When to use Server Components or SSR (Next.js)?">
A: SSR improves SEO and TTFB. Server Components help avoid unnecessary client-side renders.
</QAItem>

</FolderAccordion>

<FolderAccordion title="Tools and Patterns" level={2}>

<QAItem question="How does using TypeScript impact architecture?">
A: It helps prevent errors during development and makes code more predictable and documented.
</QAItem>

<br />

<QAItem question="Best practices with Tailwind, Styled Components, or CSS Modules?">
A: Separate visual responsibilities, avoid logic in styles, and prefer consistent patterns throughout the project.
</QAItem>

<br />

<QAItem question="What is the importance of linting, testing, and CI/CD?">
A: Linting prevents style/code issues. Testing ensures stability. CI/CD automates delivery and reduces errors.
</QAItem>

</FolderAccordion>

<FolderAccordion title="Security" level={2}>

<QAItem question="Architectural security concerns in the frontend?">
A: Input sanitization, correct use of tokens and headers, avoid exposing sensitive data in the bundle.
</QAItem>

<br />

<QAItem question="How to protect sensitive information in the frontend?">
A: Do not put secrets in client code. Use environment variables on the backend and expose only what is necessary via a secure API.
</QAItem>

</FolderAccordion>

<FolderAccordion title="References" level={2}>

- [The Clean Architecture by Uncle Bob](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Component-Driven Development](https://www.componentdriven.org/)
- [Official Next.js Guide on Project Architecture](https://nextjs.org/docs/advanced-features/project-structure)

</FolderAccordion>

</FolderAccordion>

<FolderAccordion title="React Questions" level={1}>

_Here we can see some theoretical things that you will probably face in an interview_

<FolderAccordion title="Reconciliation Algorithm and Performance" level={2}>

<QAItem question="How does the React Reconciliation algorithm work?">
A: The React Reconciliation algorithm is the process by which React efficiently updates the DOM. When a component's state or props change, React creates a new virtual DOM tree and compares it with the previous one (diffing).

- React uses a heuristic O(n) algorithm instead of traditional O(n³) tree diffing
- First compares elements of the same type
- Uses keys to identify which children were changed, added, or removed
- Updates only the parts of the DOM that changed
</QAItem>

</FolderAccordion>

<FolderAccordion title="Code-splitting in React" level={2}>

<QAItem question="What is code-splitting and how does React support it?">
A: Code-splitting is a technique to divide your bundle into smaller chunks that can be loaded on demand, improving initial load time. React supports code-splitting via:

<br />

1. **React.lazy():** Allows components to be loaded only when needed

<br />

2. **Suspense**: Provides a loading state while components are being loaded

<br />

3. **Route-based splitting**: Loading components based on routes
</QAItem>

</FolderAccordion>

<FolderAccordion title="Render Props Pattern vs Hooks" level={2}>

<QAItem question="What is the render props pattern and how does it compare to Hooks?">
A: The render props pattern is a technique for sharing code between components using a prop whose value is a function. It was popular before hooks were introduced.

<br />

**Render Props**:

- Passes functions as props to share logic
- Can lead to "callback hell" and deeply nested components
- More verbose than hooks
- Still useful for certain UI composition patterns

<br />

**Hooks**:

- More concise and readable
- Easier to compose multiple pieces of logic
- Cannot be used conditionally (must follow hook rules)
- Sometimes less flexible for complex UI composition
</QAItem>

</FolderAccordion>

<FolderAccordion title="State Management" level={2}>

<QAItem question="What are the different types of state in React applications?">
A:

<br />

- **Client State**
  - UI state (modals, tabs, etc)
  - User preferences
  - Application state, not from server
  - Complex client-side logic

<br />

- **Server State**
  - Data fetched from APIs
  - Data that needs caching
  - Background refetching
  - Optimistic Updates - Optimistic updates are a UI pattern where the application immediately updates the interface after a user action, without waiting for server confirmation.

<br />

- **URL State**
  - Pros: Shareable, Favorable, State Persistence
  - Uses: Filters, Selected Tabs, Selected Items, Multi-Step Flows
  - When not to use: Sensitive Information, High-frequency changes, Large Data Structures
</QAItem>

</FolderAccordion>

<FolderAccordion title="useReducer and useState" level={2}>

<QAItem question="How does useReducer work and what are its parameters?">
A: We can implement a custom hook similar to useState using useReducer, creating a simple reducer that replaces the state with what is dispatched to it. Returns a tuple with the state and dispatch function.

```tsx
const [state, dispatch] = useReducer(reducer, initialArg, init?)
```

<br />

**reducer**: Must be pure, must receive **state** and **action** as arguments, must return the **next state**

<br />

**initialArg**

<br />

**init**: Initializer function that should return the initial state
</QAItem>

</FolderAccordion>

<FolderAccordion title="useEffect Drama" level={2}>

<QAItem question="What are the differences between useEffect and useLayoutEffect?">
A:

<br />

**useEffect** and **useLayoutEffect** are both hooks for handling side effects, but differ in their execution timing:

<br />

**useEffect**

- executes asynchronously after the browser has painted
- doesn't block the browser from updating
- side effects

<br />

**useLayoutEffect**

- executes synchronously **after** React performs DOM mutations
- but **before** browser painting
- blocks the browser from painting until the effect is completed
- modifies the DOM and wants to avoid visual flickering
</QAItem>

</FolderAccordion>

<FolderAccordion title="API Calls" level={2}>

<QAItem question="What are the limitations of using useEffect for API calls?">
A:

<br />

**useEffect Limitations**

- Race Conditions: handling non-sequential order
- No built-in features for: retry, deduplication (multiple components requesting the same data), manual loading and error states, complex to clean up and avoid memory leaks, waterfalls (Sequential data dependencies create request cascades), no background refetching
</QAItem>

<br />

<QAItem question="What are the best practices for making API calls in React?">
A:

<br />

**Best Practices**

- Custom Hook with AbortController: Create a new AbortController for this request, pass the signal to the request, if the signal is not aborted set the data. Cleanup: abort the request if component is unmounted or URL changes
- Custom Hook with AbortController and Request Deduplication: Create a cache key based on URL and options, check if there's already a pending request for this URL, if not create a new promise and store it in the cache (local), remove from cache when completed
</QAItem>

</FolderAccordion>

<FolderAccordion title="Refs Refs Refs" level={2}>

<QAItem question="What is forwardRef and when should you use it?">
A:

<br />

**forwardRef**: component receives a ref and forwards it to a child DOM element or component. Use cases: accessing a DOM element inside a child, imperatively triggering actions on a child component, triggering input focus via ref
</QAItem>

<br />

<QAItem question="What is useImperativeHandle and when should you use it?">
A:

<br />

**useImperativeHandle**: customizes the instance exposed when using a reference, allows a child to expose specific functions or properties to the parent. Use cases: wanting to limit which parts of a component are accessible via ref, exposing and customizing imperative methods. Example: modal triggering API on close
</QAItem>

</FolderAccordion>

<FolderAccordion title="Performance Measurement & Optimization" level={2}>

<QAItem question="How do you measure React component performance?">
A:

<br />

**How to measure?**

- DevTools: Record and interact, Analyze the flamegraph
- Render duration, Commit frequency, Wasted renders
- Custom hook with `performance.now()`
- `why-did-you-render` library to track unnecessary re-renders
- when **useMemo** is useful: calculation is computationally expensive, dependencies change infrequently, calculation result is used in the rendering phase
</QAItem>

<br />

<QAItem question="What is the practical approach to performance optimization?">
A:

<br />

**Practical Approach**:

1. identify bottlenecks using tools
2. measure impact of optimizations
3. apply targeted optimizations
4. measure again
</QAItem>

<br />

<QAItem question="When should you use useCallback?">
A:

<br />

**useCallback**: memoized version of the callback function that only changes if one of its dependencies has changed. Has a small performance cost, just part of the optimization strategy, not everywhere. Use cases: passing functions to optimized child components
</QAItem>

</FolderAccordion>

<FolderAccordion title="INP Optimization" level={2}>

<QAItem question="What is INP and how would you optimize it in a React application?">
A: INP (Interaction to Next Paint) is a Core Web Vital that measures responsiveness to user interactions such as clicks, taps, and keyboard inputs. It became an official Google ranking factor in March 2024, with a "good" threshold below 200ms. To optimize INP in a React application:

1. Profile performance using Chrome DevTools Performance panel
2. Implement code-splitting and lazy loading with React.lazy() and Suspense
3. Optimize event handlers with debouncing and event delegation
4. Leverage React 18 concurrent features with startTransition
5. Eliminate unnecessary re-renders with React.memo() and useMemo()
6. Split long tasks into smaller chunks

As seen in the Vio case study, these optimizations can improve INP from poor scores (380ms) to good ones (175ms).
</QAItem>

</FolderAccordion>

<FolderAccordion title="Migrating to Next.js" level={2}>

<QAItem question="How would you approach migrating a client-rendered React application to Next.js for better performance?">
A: Based on DoorDash's migration strategy:

1. Implement an incremental approach - migrate page by page
2. Create a bridge between environments with shared context and isSSR flag
3. Optimize SSR with lazy hydration for non-critical components
4. Implement file-based routing replacing React Router
5. Focus on high-impact pages first
6. Establish monitoring and fallbacks
</QAItem>

<br />

<QAItem question="What challenges might you face when migrating to Next.js App Router and how would you address them?">
A: Based on Inngest's experience:

1. **Understanding the new caching behavior**: Start by disabling cache for dynamic data (export const dynamic = "force-dynamic")
2. **Managing global state across layouts**: Move global state to URL parameters
3. **Adapting to new routing conventions**: Leverage file-based structure with layout.js, page.js, loading.js, error.js
4. **Balancing static and dynamic content**: Use static rendering where possible, stream dynamic content with React's streaming SSR
</QAItem>

</FolderAccordion>

<FolderAccordion title="SSR, CSR, and Hybrid Approaches" level={2}>

<QAItem question="How would you decide between SSR, CSR, and hybrid approaches in a Next.js application?">
A: **Use SSR for**: Entry points and landing pages that need SEO, content-heavy pages, pages indexable by search engines, initial application shell. **Use CSR for**: Highly interactive parts after initial load, internal dashboards, features requiring frequent updates, components dependent on client-side APIs. **Hybrid (recommended)**: SSR for initial shell and critical content, CSR for subsequent interactions, progressive hydration, streaming SSR.
</QAItem>

</FolderAccordion>

<FolderAccordion title="Caching Strategies" level={2}>

<QAItem question="What caching strategies would you implement in a Next.js application to balance performance and data freshness?">
A:

1. **CDN/Edge**: Configure cache headers, use ISR with revalidation, stale-while-revalidate
2. **App Router caching**: cache: 'no-store' for dynamic data, time-based revalidation with next.revalidate, on-demand revalidation
3. **Client-side**: React Query or SWR with staleness times
4. **Monitoring**: Add monitoring, implement cache invalidation, test with fresh and cached data
</QAItem>

</FolderAccordion>

<FolderAccordion title="State Management Evolution" level={2}>

<QAItem question="How has state management in React applications evolved, and what approach would you recommend for a large-scale application?">
A: **Current best practices**:

1. Keep state local when possible
2. React Context for shared state
3. React Query/SWR for server state, Zustand or Jotai for global UI state, React Hook Form for forms
4. Server-side state with Server Components
5. Redux only for complex cases

**Recommendation**: Modular approach, separate server state (React Query) from client state (Context/Zustand), place state close to where needed, URL params for routing state, proper memoization.
</QAItem>

</FolderAccordion>

<FolderAccordion title="Accessibility in React/Next.js" level={2}>

<QAItem question="How would you ensure accessibility in a React/Next.js application?">
A:

1. **Semantic HTML and ARIA**: Appropriate elements, ARIA when needed, follow ARIA Authoring Practices
2. **Keyboard navigation**: All interactive elements keyboard accessible, manage focus for modals, expected shortcuts
3. **Test with assistive technologies**: Screen readers, keyboard-only testing, axe-core or Lighthouse
4. **Framework features**: Next.js built-in features, accessible component libraries
5. **From the start**: Include in design, train developers, part of definition of done
</QAItem>

</FolderAccordion>

</FolderAccordion>

<FolderAccordion title="React Performance & Best Practices" level={1}>

_Some best practices to keep the performance on top_

<FolderAccordion title="1. Eliminating Async Waterfalls" level={2}>

<QAItem question="What are 'async waterfalls' and why are they problematic?">
A: Async waterfalls occur when asynchronous operations are executed sequentially, one waiting for the other to complete, even when there's no real dependency between them. This is problematic because:

- Significantly increases total loading time
- Unnecessarily blocks the UI
- Wastes resources by not leveraging parallelism
</QAItem>

<br />

**❌ Incorrect (Sequential/Waterfall):**

```tsx
async function load(id: string, skip: boolean) {
  const data = await fetchData(id); // Blocks even if skip is true
  if (skip) return null;
  return process(data);
}
```

<br />

**✅ Correct (Non-blocking):**

```tsx
async function load(id: string, skip: boolean) {
  if (skip) return null;
  const data = await fetchData(id);
  return process(data);
}
```

<br />

<QAItem question="How to use Promise.all to avoid waterfalls in multiple async calls?">
A: When there are multiple independent async calls, use `Promise.all()` or start the promises simultaneously before awaiting.
</QAItem>

<br />

**❌ Incorrect (Sequential):**

```tsx
const userData = await fetchUser(id);
const posts = await fetchPosts(id); // Unnecessarily waits for user to finish
const comments = await fetchComments(id); // Waits for user AND posts to finish
```

<br />

**✅ Correct (Parallel):**

```tsx
// Option 1: Promise.all when all are needed
const [userData, posts, comments] = await Promise.all([
  fetchUser(id),
  fetchPosts(id),
  fetchComments(id),
]);

// Option 2: Start all simultaneously and await as needed
const userDataPromise = fetchUser(id);
const postsPromise = fetchPosts(id);
const commentsPromise = fetchComments(id);

const userData = await userDataPromise;
const posts = await postsPromise;
const comments = await commentsPromise;
```

<br />

<QAItem question="How to avoid waterfalls with TanStack Query?">
A: With TanStack Query, use `enabled` only for necessary validation, not to create cascades. Independent queries should start simultaneously.
</QAItem>

<br />

**❌ Incorrect:**

```tsx
const { data: user } = useQuery({
  queryKey: ["user", id],
  queryFn: () => fetchUser(id),
});

const { data: posts } = useQuery({
  queryKey: ["posts", id],
  queryFn: () => fetchPosts(id),
  enabled: !!user, // Waterfall! Only fetches posts after user
});
```

<br />

**✅ Correct (Parallel):**

```tsx
const { data: user } = useQuery({
  queryKey: ["user", id],
  queryFn: () => fetchUser(id),
});

const { data: posts } = useQuery({
  queryKey: ["posts", id],
  queryFn: () => fetchPosts(id),
  enabled: !!id, // Doesn't depend on user
});
```

<br />

**✅ Correct (Real Dependency):**

```tsx
const { data: user } = useQuery({
  queryKey: ["user", id],
  queryFn: () => fetchUser(id),
});

const { data: posts } = useQuery({
  queryKey: ["posts", user?.userId],
  queryFn: () => fetchPosts(user.userId),
  enabled: !!user?.userId, // OK: real data dependency
});
```

<br />

<QAItem question="What is 'data proximity' and how to apply this concept?">
A: Data proximity means fetching data as close as possible to where it will be consumed, avoiding "prop drilling" of pending states.
</QAItem>

<br />

**❌ Incorrect (Loading Prop Drilling):**

```tsx
function Parent() {
  const { data: user } = useQuery(["user"], fetchUser);
  const { data: posts } = useQuery(["posts"], fetchPosts);
  const { data: comments } = useQuery(["comments"], fetchComments);
  return <Child user={user} posts={posts} comments={comments} />;
}

function Child({ user, posts, comments }) {
  return <CommentsList comments={comments} />;
}
```

<br />

**✅ Correct (Proximity):**

```tsx
function Parent() {
  const { data: user } = useQuery(["user"], fetchUser);
  return (
    <>
      <UserProfile user={user} />
      <PostsSection userId={user?.id} />
    </>
  );
}

function PostsSection({ userId }) {
  const { data: posts } = useQuery(
    ["posts", userId],
    () => fetchPosts(userId),
    { enabled: !!userId },
  );
  return <PostsList posts={posts} />;
}
```

</FolderAccordion>

<FolderAccordion title="2. Render Optimization and Re-renders" level={2}>

<QAItem question="When and how to use useMemo to optimize render calculations?">
A: Use `useMemo` to avoid unnecessary recalculations of complex logic or array transformations that don't need to be redone on every render.
</QAItem>

<br />

**❌ Incorrect:**

```tsx
function ProductList({ products, filter, sortBy }) {
  const filtered = products.filter((p) => p.category === filter);
  const sorted = filtered.sort((a, b) => {
    if (sortBy === "price") return a.price - b.price;
    return a.name.localeCompare(b.name);
  });
  return (
    <div>
      {sorted.map((p) => (
        <Product key={p.id} {...p} />
      ))}
    </div>
  );
}
```

<br />

**✅ Correct:**

```tsx
function ProductList({ products, filter, sortBy }) {
  const sorted = useMemo(() => {
    const filtered = products.filter((p) => p.category === filter);
    return filtered.sort((a, b) => {
      if (sortBy === "price") return a.price - b.price;
      return a.name.localeCompare(b.name);
    });
  }, [products, filter, sortBy]);
  return (
    <div>
      {sorted.map((p) => (
        <Product key={p.id} {...p} />
      ))}
    </div>
  );
}
```

<br />

<QAItem question="When to use useCallback and what's its impact on function stability?">
A: Use `useCallback` for functions passed as props to child components that use `React.memo`, or when the function is a dependency of another hook.
</QAItem>

<br />

**❌ Incorrect:**

```tsx
const MemoizedButton = React.memo(Button);

function Parent({ items }) {
  const handleClick = (id: string) => {
    console.log("Clicked", id);
  };
  return items.map((item) => (
    <MemoizedButton key={item.id} onClick={() => handleClick(item.id)} />
  ));
}
```

<br />

**✅ Correct:**

```tsx
const MemoizedButton = React.memo(Button);

function Parent({ items }) {
  const handleClick = useCallback((id: string) => {
    console.log("Clicked", id);
  }, []);
  return items.map((item) => (
    <MemoizedButton key={item.id} id={item.id} onClick={handleClick} />
  ));
}
```

**⚠️ Important:** Don't use `useCallback` unnecessarily. Only use when: the function is passed to a memoized component (`React.memo`), or the function is a dependency of another hook (`useEffect`, `useMemo`).

<br />

<QAItem question="Why shouldn't we put high-frequency states in React Context?">
A: High-frequency states (like text inputs) in global Contexts cause re-renders in all components consuming that context.
</QAItem>

<br />

**❌ Incorrect:**

```tsx
const SearchContext = createContext();

function SearchProvider({ children }) {
  const [searchTerm, setSearchTerm] = useState("");
  return (
    <SearchContext.Provider value={{ searchTerm, setSearchTerm }}>
      {children}
    </SearchContext.Provider>
  );
}

function UnrelatedComponent() {
  const { searchTerm } = useContext(SearchContext);
  return <div>Static content</div>;
}
```

<br />

**✅ Correct:**

```tsx
function SearchInput() {
  const [searchTerm, setSearchTerm] = useState("");
  return (
    <input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
  );
}

// OR: Zustand with granular selectors
const useSearchStore = create((set) => ({
  searchTerm: "",
  setSearchTerm: (term) => set({ searchTerm: term }),
}));

function SearchInput() {
  const searchTerm = useSearchStore((s) => s.searchTerm);
  const setSearchTerm = useSearchStore((s) => s.setSearchTerm);
  return (
    <input value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} />
  );
}
```

</FolderAccordion>

<FolderAccordion title="3. JavaScript Performance and Structures" level={2}>

<QAItem question="How to avoid multiple iterations over the same list?">
A: Combine operations like `filter`, `map`, and `reduce` into a single pass.
</QAItem>

<br />

**❌ Incorrect (Multiple Iterations):**

```tsx
function processProducts(products: Product[]) {
  const active = products.filter((p) => p.active);
  const withDiscount = active.filter((p) => p.discount > 0);
  const prices = withDiscount.map((p) => p.price * (1 - p.discount));
  const total = prices.reduce((sum, p) => sum + p, 0);
  return total;
}
```

<br />

**✅ Correct (Single Iteration):**

```tsx
function processProducts(products: Product[]) {
  return products.reduce((total, product) => {
    if (!product.active || product.discount === 0) return total;
    const discountedPrice = product.price * (1 - product.discount);
    return total + discountedPrice;
  }, 0);
}
```

<br />

<QAItem question="What is the 'early return' pattern and how does it improve readability?">
A: Early return means returning early for error or loading states, avoiding excessive nesting.
</QAItem>

<br />

**❌ Incorrect:**

```tsx
function ProductPage({ productId }) {
  const {
    data: product,
    isLoading,
    error,
  } = useQuery(["product", productId], fetchProduct);
  return (
    <div>
      {isLoading ? (
        <Loading />
      ) : error ? (
        <Error />
      ) : product ? (
        <div>
          <h1>{product.name}</h1>
        </div>
      ) : null}
    </div>
  );
}
```

<br />

**✅ Correct:**

```tsx
function ProductPage({ productId }) {
  const {
    data: product,
    isLoading,
    error,
  } = useQuery(["product", productId], fetchProduct);
  if (isLoading) return <Loading />;
  if (error) return <Error />;
  if (!product) return null;
  return (
    <div>
      <h1>{product.name}</h1>
    </div>
  );
}
```

<br />

<QAItem question="Why is it important to cleanup in useEffect and how to implement it?">
A: Cleanup prevents memory leaks and inconsistent behavior when the component unmounts.
</QAItem>

<br />

**❌ Incorrect:**

```tsx
useEffect(() => {
  const interval = setInterval(() => fetchData(), 1000);
  // No cleanup!
}, []);
```

<br />

**✅ Correct:**

```tsx
useEffect(() => {
  const interval = setInterval(() => fetchData(), 1000);
  return () => clearInterval(interval);
}, []);
```

<br />

**✅ Correct (AbortController for fetch):**

```tsx
useEffect(() => {
  const abortController = new AbortController();
  fetchData({ signal: abortController.signal })
    .then(setData)
    .catch((err) => {
      if (err.name !== "AbortError") setError(err);
    });
  return () => abortController.abort();
}, []);
```

</FolderAccordion>

<FolderAccordion title="4. Golden Rules - Summary" level={2}>

<QAItem question="What are the main golden rules for React performance?">
A:

- **Parallel Queries**: With TanStack Query, start independent queries simultaneously. Use `enabled` only for necessary validation.
- **useMemo for Transformations**: Use for calculations with array iterations, values used in multiple places, or expensive computations.
- **useCallback for Stability**: Use when function is passed to `React.memo` or is a hook dependency.
- **Local vs Global State**: Local: inputs, forms. Zustand: global state with selectors. TanStack Query: server state.
- **Avoid Waterfalls**: Don't await conditionally used data. Use `Promise.all`. Start independent queries together.
- **Early Returns**: Return loading/error before main JSX. Avoid nested ternaries.
</QAItem>

</FolderAccordion>

</FolderAccordion>

<FolderAccordion title="Another Common Questions" level={1}>

<QAItem question="What are the strategies we can use to optimize the performance of web applications?">
A: CDNs, GraphQL (maybe) to reduce overfetching, improve backend performance, use SSR and/or SSG, lazy loading for loading assets only when it's needed, minimize and compress HTML, CSS and JS files, and optimize images by compressing and resizing them.
</QAItem>

<br />

<QAItem question="What are Web Vitals (LCP, FID, CLS)? And how are they applied in the real world?">
A: Web Vitals are standardized metrics to measure the quality of the navigation inside a website:

- LCP (Largest Contentful Paint) - LCP measures the time it takes for the largest visible content element to be fully loaded and rendered. A LCP is considered good when it takes less than 2.5 seconds.
- FID (First Input Delay) - FID measures the time it takes for the browser to respond to the user's first interaction. A FID is considered good when it takes less than 100 milliseconds.
- CLS (Cumulative Layout Shift) - CLS measures the visual stability of a page by calculating the sum of layout shift scores for all unexpected layout shifts during the entire lifespan of the page.
</QAItem>

<br />

<QAItem question="What is the WAI-ARIA standard?">
A: Web Accessibility Initiative - Accessible Rich Internet Applications, is a technical specification developed by the World Wide Web Consortium (W3C). The purpose of WAI-ARIA is to improve the accessibility of web content and applications, especially for users with disabilities who rely on assistive technologies, such as screen readers or alternative input devices.
</QAItem>

<br />

<QAItem question="In which cases is it worth building an SPA?">
A:

- Mobile app-like experience and PWA
- Complex state management, because they are able to maintain persistent state and handle real-time updates
- Highly interactive user interfaces, because there's no reload, so transitions between views are faster
</QAItem>

<FolderAccordion title="JavaScript" level={2}>

<QAItem question="What is the advantage of using a Map instead of an object?">
A:

- With maps you can use keys of any type, not only strings as in javascript objects
- Provides an iterator for easy for-of usage
- Support millions of items

```javascript
// Map with different key types
const map = new Map();
map.set('string', 'value1');
map.set(1, 'value2');
map.set({}, 'value3');

// Easy iteration
for (const [key, value] of map) {
  console.log(key, value);
}
```
</QAItem>

<br />

<QAItem question="What is the difference between Map and WeakMap?">
A: WeakMaps keys must be objects. Besides that, WeakMaps have weak references to the keys, so unused keys can be easily removed by the garbage collector
</QAItem>

<br />

<QAItem question="What are closures? (a very common question)">
A: One function that has a function inside, and return it. This technique is used to capture the scope on which they were defined, so you can use variables of that scope outside it.
</QAItem>

<br />

<QAItem question="What is hoisting?">
A: Elevate functions and variables declarations to the "top scope". This allows you to use a function or a variable before it is defined in your .js file.

```javascript
// Function hoisting
console.log(add(2, 3)); // Works! Returns 5
function add(a, b) {
  return a + b;
}

// Variable hoisting (var)
console.log(x); // undefined (not an error)
var x = 5;

// Let/const are NOT hoisted the same way
console.log(y); // ReferenceError!
let y = 10;
```
</QAItem>

<br />

<QAItem question="How does equality work in JS? What is the difference between using === and Object.is()?">
A: Object.is considers NaN equals to NaN and -0 different than +0.

```javascript
// === behavior
NaN === NaN;        // false
-0 === +0;          // true

// Object.is behavior
Object.is(NaN, NaN);  // true
Object.is(-0, +0);    // false

// Same for other values
Object.is(1, 1);      // true
Object.is({}, {});    // false
```
</QAItem>

<br />

<QAItem question="What is the purpose of Object.freeze()?">
A: Makes an object immutable, preventing it to have its value changed.

```javascript
const obj = { name: 'John', age: 30 };
Object.freeze(obj);

obj.age = 31;        // Ignored (or throws in strict mode)
obj.city = 'NYC';    // Ignored
delete obj.name;     // Ignored

console.log(obj);    // { name: 'John', age: 30 }
```
</QAItem>

<br />

<QAItem question="What is the difference between an async-await function and using a chain of .then?">
A: Callback hell
</QAItem>

<br />

<QAItem question="How do generators work?">
A: Generators are on-demand functions, they can be paused and resumed, and the state is maintained along these "pauses and resumes". They return a generator object, each key of this object is the result of and yield operation, the last key is the return result.

```javascript
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
  return 'done';
}

const gen = numberGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: 'done', done: true }
```
</QAItem>

</FolderAccordion>

<FolderAccordion title="CSS" level={2}>

<QAItem question="How does CSS-in-JS work?">
A: It is an approach that allows writing CSS directly within JavaScript files, making code maintenance and modularization easier.
</QAItem>

<br />

<QAItem question="Why does Facebook no longer want to follow the same direction as CSS-in-JS?">
A: Doesn't generate a static CSS file, it generates a JS file and set all the styles through it, and then the styles interact with the browser through the CSSStyleSheet API. Generating a static CSS file would be more performatic.
</QAItem>

<br />

<QAItem question="What is the proposal of the Stylex library?">
A: It's a library to manage CSS styles in an efficient and modular way.
</QAItem>

<br />

<QAItem question="How to use nesting with pure CSS only?">
A: It's being discussed lately, it's very recent and will be implemented in the next versions. But, so far it's only possible by using CSS preprocessors.
</QAItem>

<br />

<QAItem question="What are container queries?">
A: A way to apply styles based on the container size, instead of the window view size It makes the styles more responsive.

```css
/* Container query */
.card-container {
  container-type: inline-size;
}

@container (min-width: 400px) {
  .card {
    display: grid;
    grid-template-columns: 1fr 2fr;
  }
}

/* Traditional media query (window-based) */
@media (min-width: 400px) {
  .card {
    display: grid;
  }
}
```
</QAItem>

<br />

<QAItem question="How does the CSS grid subgrid work?">
A: The CSS Grid subgrid feature is an extension of the CSS Grid Layout Module that allows a nested grid to inherit its parent grid's rows or columns. This is especially useful when you want to align the content of nested grid items with the parent grid's structure, without having to duplicate row and column definitions or manage complex positioning with margins or padding.

```css
.parent-grid {
  display: grid;
  grid-template-columns: 1fr 2fr 1fr;
  gap: 1rem;
}

.child-grid {
  display: grid;
  grid-column: span 3;
  grid-template-columns: subgrid; /* Inherits parent columns */
}
```
</QAItem>

</FolderAccordion>

<FolderAccordion title="React" level={2}>

<QAItem question="What is the Virtual DOM? And why is it often more performant than manipulating the 'real' DOM?">
A:

- Virtual DOM is a JavaScript object containing a replica to the real DOM, it is capable of making comparisons with the real DOM, and then apply patches avoiding a full re-render in the DOM, rerendering only what have changed.
- Virtual DOM is a programming concept where a virtual representation of a UI is kept in memory synced with "Real DOM" by a library such as ReactDOM and this process is called reconciliation
- Virtual DOM makes the performance faster, not because the processing itself is done in less time. The reason is the amount of changed information – rather than wasting time on updating the entire page, you can dissect it into small elements and interactions
</QAItem>

<br />

<QAItem question="Explain why the useState hook accepts a function as an initial value">
A: To allow the initial value to be calculated only once, instead of every time

```jsx
// Without function: expensive calculation runs on every render
const [value, setValue] = useState(calculateExpensiveValue());

// With function: calculation runs only once on mount
const [value, setValue] = useState(() => calculateExpensiveValue());
```
</QAItem>

<br />

<QAItem question="What is the difference between the hooks useState and useReducer?">
A: useState is better for simple state management, without too much logic involved, and useReducer was designed to handle complex state logics, and states that requires transition and dispatch actions.

```jsx
// useState - simple
const [count, setCount] = useState(0);
setCount(count + 1);

// useReducer - complex state logic
const [state, dispatch] = useReducer(reducer, { count: 0, step: 1 });
dispatch({ type: 'increment' });
dispatch({ type: 'changeStep', payload: 5 });
```
</QAItem>

<br />

<QAItem question="Under what circumstances does a component re-render in React?">
A:

- Changes in props: When a component receives new props, it triggers a re-render. This happens even if the new props are the same as the old ones.
- Changes in state: When a component's state is updated, a re-render is triggered.
- Parent component re-renders: When a parent component re-renders, by default, its child components also re-render.
- Context changes: If a component is consuming values from a React context using useContext (in functional components), and the context value changes, the component will re-render.
- Using hooks with dependencies: Hooks like useEffect, useMemo, and useCallback accept dependency arrays as their second argument. When any of the listed dependencies change, the effect will run, or the memoized value or callback will be recomputed, potentially causing the component to re-render.
</QAItem>

<br />

<QAItem question="How can we prevent unnecessary rerenders?">
A:

- React.memo
- Use the hook dependencies correctly in useCallback, useEffect and useMemo to avoid re-renders
- For big forms, prefer useRef over useState

```jsx
// React.memo prevents re-render if props don't change
const MemoizedComponent = React.memo(({ data }) => {
  return <div>{data.name}</div>;
});

// useCallback stabilizes function reference
const handleClick = useCallback(() => {
  console.log('clicked');
}, []);

// useMemo caches computed value
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data);
}, [data]);
```
</QAItem>

<br />

<QAItem question="What is the advantage of using the React.memo API?">
A: Prevents unnecessary renders when the component's props haven't changed, improving performance
</QAItem>

<br />

<QAItem question="What are the purposes of the hooks useRef, useMemo, and useCallback?">
A:

- useRef: Allows you to create a mutable reference object that persists across renders. It is commonly used to store references to DOM elements, but can also be used to store values that should persist without triggering a rerender (input values for example).
- useMemo: Memoizes a computed value, preventing unnecessary recomputations when dependencies haven't changed. This can improve performance when working with expensive computations that depend on specific prop or state values.
- useCallback: Memoizes a callback function, ensuring that the same instance of the function is reused across renders unless its dependencies change. This is useful for preventing unnecessary rerenders in child components that receive the callback as a prop.
</QAItem>

<br />

<QAItem question="What is virtualization? And what is it for?">
A: Virtualization is a technique used to optimize the rendering of large lists or grids by only rendering the visible items on the screen. It improves performance by reducing the number of DOM elements created and updated, minimizing memory usage, and reducing layout calculations.
</QAItem>

<br />

<QAItem question="Explain how the useEffect hook works">
A: The useEffect hook is used to perform side effects in functional components, such as fetching data, updating the DOM, or subscribing to events. It takes two arguments: a function that contains the side effect, and an optional dependency array. The effect function runs after the component renders and updates. If the dependency array is provided, the effect will only run when one of the listed dependencies changes. If the array is empty, the effect will run only on mount and unmount.
</QAItem>

<br />

<QAItem question="How can we do event cleanup in useEffect?">
A: By returning a "cleanup function" in the end of the useEffect A cleanup function is a function with a removeEventListener call inside it. As you are returning this cleanup function, the cleanup will happen every time the effect happens (it will vary on the dependencies array of your useEffect)

```jsx
useEffect(() => {
  const handleResize = () => {
    console.log('Window resized');
  };
  
  // Add event listener
  window.addEventListener('resize', handleResize);
  
  // Cleanup function
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);
```
</QAItem>

<br />

<QAItem question="What is the recommended way to consume external data in React?">
A: useEffect hook to fetch data when the component mounts or when relevant dependencies change. The fetched data can then be stored in the component's state using the useState or useReducer hooks.
You can use axios or fetch for consuming REST APIs, and apollo-client, relay or urql if you are consuming a GraphQL API. You can also consume other types of APIs, for example gRPC and SOAP, although these API patterns are not that common in frontend applications.
tRPC (t3-app) and server-components (next.js) are a very recent way to consume external data.
</QAItem>

<br />

<QAItem question="What is the difference between server state and application state?">
A:

- Server state refers to the data stored on the server or external services, typically fetched via APIs.
- Application state refers to the data that is specific to a user's interaction with the application, such as user preferences, UI state, context or data that is temporarily cached on the client-side.
</QAItem>

<br />

<QAItem question="How can a React application be deployed without any meta-framework?">
A:

- Write a build script in the package.json, and also a start build script
- Choose a provider that supports a SPA.
- Deploy the application through CLI, FTP or git remote repository.
- Generate the build
- Configure the provider to start the application pointing to the build directory (usually dist)
</QAItem>

<br />

<QAItem question="What is a meta-framework in the context of web development?">
A:

- Framework built on top of other frameworks or libraries
- Next.js --> React.js
- Nuxtjs --> Vue.js
- NestJS --> Express and Fastify
- Type-GraphQL --> GraphQL
</QAItem>

</FolderAccordion>

<FolderAccordion title="Next.js" level={2}>

<QAItem question="What is the difference between getServerSideProps and getStaticProps?">
A:

- getStaticProps - used to get de component props and then render it into a static HTML page at build time
- getServerSideProps - used to get the component props and then render it into a static HTML page at run time

```jsx
// getStaticProps - runs at build time
export async function getStaticProps() {
  const data = await fetchData();
  return { props: { data } };
}

// getServerSideProps - runs on every request
export async function getServerSideProps(context) {
  const data = await fetchData(context.params.id);
  return { props: { data } };
}
```
</QAItem>

<br />

<QAItem question="What is the purpose of the getStaticPaths function?">
A: Is used when your dynamic page has the getStaticProps. Nextjs needs to know what are the possible paths for your dynamic route, so you map them on the getStaticProps function. You can use getStaticProps without getStaticPaths; getStaticPaths is only a complement in case of dynamic routes

```jsx
// For dynamic routes like /posts/[id]
export async function getStaticPaths() {
  const posts = await getAllPosts();
  
  const paths = posts.map(post => ({
    params: { id: post.id }
  }));
  
  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const post = await getPost(params.id);
  return { props: { post } };
}
```
</QAItem>

<br />

<QAItem question="How does the next/image API work? And why does it improve the app's performance?">
A:

- The image is optimized by the Next.js server, or an external image optimization service. The optimization includes resizing, format conversion (to WEBP), and compression.
- The optimized image is served to the client with cache headers to enable caching by the browser or a CDN, which can improve performance on subsequent requests.
</QAItem>

<br />

<QAItem question="Explain how you would deploy a Next application without hosting it on Vercel">
A: You can deploy a Next.js application on any platform that supports Node.js, the only difference is that on Vercel this process is automated, is hidden by a great DX.
</QAItem>

<br />

<QAItem question="How do API routes work?">
A: Next.js API routes provide a built-in solution for creating API endpoints within a Next.js application. They are server-side functions that run when a request is made to their corresponding URL. To create an API route, simply create a new file with a .js extension inside the pages/api folder, and export a default request handler function.

```jsx
// pages/api/hello.js
export default function handler(req, res) {
  if (req.method === 'GET') {
    res.status(200).json({ message: 'Hello World' });
  } else {
    res.status(405).json({ error: 'Method not allowed' });
  }
}

// Usage: fetch('/api/hello')
```
</QAItem>

<br />

<QAItem question="Is it possible to API Routes if the app is not hosted on Vercel?">
A: Yes, you can use Next.js API routes even if your app is not hosted on Vercel. API routes work on any platform that supports Node.js, including custom deployments or other hosting providers.
</QAItem>

<br />

<QAItem question="How can we integrate AMP with Next?">
A: You'll need to import the withAmp higher-order component from next/amp and wrap your page component with it.
</QAItem>

<br />

<QAItem question="What is the advantage of using Serverless mode?">
A:

- Improved scalability, as serverless functions can automatically scale based on demand.
- Cost efficiency, as you only pay for the compute resources you actually use.
- Easier deployment and management, as you don't need to manage your own servers or infrastructure.
- Faster response times due to the serverless functions being deployed closer to the users.
</QAItem>

<br />

<QAItem question="Is it possible to use a static CDN with Next?">
A: Yes, you can use a static CDN with Next.js by configuring the assetPrefix option in your next.config.js file. The assetPrefix should be set to the URL of your CDN.
</QAItem>

</FolderAccordion>

</FolderAccordion>
